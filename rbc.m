(* ######################################################################### Authors: Neema Jamshidi, Jeremy S. Edwards, George M. Church,   Bernhard O. Palsson;	version defined by RBCSimVer variable;    This file has been checked against the Fortran code wrt (JSE);  1- Steady states;  2- Dynamic simulations from different initial conditions;  3- ATP loads both under and "over" load -     Checked with phaseplanes and poolplots;  4- Redox load - Checked with phaseplanes and poolplots;				  	  ######################################################################### *)    BeginPackage["rbc`"];Off[General::spell]; Off[General::spell1];RBCSimPath = Directory[];RBCSimVer =2.2;<<Statistics`LinearRegression`;<<Statistics`MultiDescriptiveStatistics`;<<Graphics`MultipleListPlot`;PHI = -Log[10,HI]+3; PHE = 7.4; HE=10^(-PHE)*1000;HI = HE/(92/100*RT); TEMP = 310;   CO2 = 1.2;  RT := 0.6; (* Donnan Ratio *)           ATPF = ATP-MGATP; (* free ATP concentration *) NAD = NADHT - NADH; NADHT = 0.089; NADP = NADPHT - NADPH; NADPHT = 0.066;LACEXT = 1.2; PYREXT = 0.06; GSSG = 0.5*(GSSGT-GSH);  GSSGT = 3.32 ; adoex = 0.00008;adeex = 0.0013; inoex = 0.0002;GLC := 5; MGT := 2.7; PI := 1.2;NAE := 140; KE = 5;S   = 1.55*^-6;    V   = 8.7*^-11;     SV  = S/V;  (*    ------------ HEXOKINASE ------------ *)HK := Block[ { KMGATP = 1.13, KMGAMG = 1.14, KMG = 1.03, KG6P = 0.334,        KPG23 = 2.7,KMGPG = 3.44,CONST = 1.55,        VM1 = 7.5095/(1+HI/2.2718*^-4+4.6015*^-6/HI)*            Exp[18.210-5637.9/TEMP],               KMAGLC = 0.051, KGLC = 0.04, Kglcg6p = 0.069, G16P = 0.16,         KG16P = KG6P,        N1 := 1 +GLC/KGLC + (1+GLC/KMAGLC)*MGATP/KMGATP + (1+GLC/KGLC)*                          MG/KMG + (1+GLC/KMAGLC)*MGATP* MG/KMGATP/KMGAMG + (                G6P/KG6P+GLC*G6P/KGLC/Kglcg6p+G16P/KG16P+GLC/KGLC*CONST)*(                1+MG/KMG)+(1+GLC/KGLC)*(DPG23/KPG23+MG*DPG23/KMG/KMGPG)},      scalehk*VM1*GLC/KMAGLC*MGATP/KMGATP*(1+2.1187*MG/KMGAMG)/N1];(* ------------ PHOSPHOGLUCOISOMERASE ------------*)       kpgi1  = 60290;      KPGI  = 0.41;      kpgi2  := kpgi1/KPGI;      PGI  := scalepgi*(kpgi1*G6P-kpgi2*F6P)*Exp[(13.042-4040.7/TEMP)];(*  ------------ PHOSPHOFRUCTOKINASE ------------*)       pfkKATP := Exp[(-5.8693*^-2+0.32796*PHI)]/1000.0;       pfkKMG  = 0.44;      pfkKF6P = 0.1;      pfkKAMP = 0.033;      pfkLO   = 1.072*^-3;       pfkVM := 250.0*Exp[(13.474-4174.8/TEMP)];      pfkKMGATP = 0.068;       L      :=       pfkLO*((1.0+ATPF/pfkKATP)^4*(1.0+MG/pfkKMG)^4)/((1.0+                  F6P/pfkKF6P)^4*(1.0+AMP/pfkKAMP)^4);      PFK   := (scalepfk*pfkVM*F6P/(pfkKF6P+F6P)*          MGATP/(pfkKMGATP+MGATP))/(1.0+L) ;(*  ------------ ALDOSE ------------*)        aldET = 0.37*^-3;       aldkeq = 0.081;       aldK1 = 3.85*^7;       aldK2 = 8.388*^5;       aldK3 = 6.84*^6;       aldK4 = 4.032*^7;       aldK5 = 2.52*^5;       aldK6 = 23.076*^6;       aldN1 = aldK1*aldK3*aldK5;       aldN2 = aldN1/aldkeq;       aldD1 = aldK5*(aldK3+aldK2);       aldD2 = aldK1*(aldK3+aldK5);       aldD3 = aldK2*aldK4;       aldD4 = aldK6*(aldK3+aldK2);       aldD5 = aldK1*aldK4;       aldD6 = aldK4*aldK6;      ALD :=       scaleald*(aldN1*FDP-aldN2*GAP*DHAP)*          aldET/(aldD1+aldD2*FDP+aldD3*GAP+aldD4*DHAP+aldD5*FDP*GAP+                      aldD6*GAP*DHAP) ;         (* ------------ TRIOSE PHOSPHATE ISOMERASE ------------*)      tpiEPSI  = 200;       tpiKTPI  = 22.0;      tpiKTP1  = 31.056*^3;      tpiKTP2  = tpiKTP1*tpiKTPI;      TPI  := scaletpi*(tpiKTP1*DHAP-tpiKTP2*GAP)*Exp[(18.475-5726.8/TEMP)];      (*------------ GLYCERALDEHYDE PHOSPHATE DEHYDROGENASE ------------*)      KGAPDH = 1.1294*^-6;      KGA1   = 115975;      KGA2   = KGA1/KGAPDH ;      GAPDH :=       scalegapdh*(KGA1*PI*GAP*(NADHT-NADH)-KGA2*DPG13*NADH*HI)*          Exp[(16.203-5021.3/TEMP)];(*  ------------ PHOSPHOGLYCERATE KINASE ------------*)       KPG =  1800;       kpgk1  = 8633310;      kpgk2 = kpgk1/KPG;      PGK  :=       scalepgk*(kpgk1*DPG13*ADP-kpgk2*PG3*ATP)*Exp[(12.560-3895.3/ TEMP)];      (*------------ DIPHOSPHOGLYCERATE MUTASE ------------*)If[PHI <6.85, KDPGM :=0, KDPGM := 2.75*^5*Exp[16.907-5236.7/TEMP]];dpgmk := 17778/10000*Exp[-144503/10000 + 148/100*PHI];      DPGM :=scaledpgm* KDPGM*DPG13/(1.0+DPG23/dpgmk);(*  ------------ DIPHOSPHOGLYCERATE PHOSPHATASE ------------*)   dpgaseVM     = 0.52;     dpgasek :=0.5208*Exp[-8.0287 + 0.98217*PHI];  DPGase := scaledpgase*dpgaseVM*DPG23/(dpgasek+DPG23);      (*  ------------ PHOSPHOGLYCEROMUTASE ------------*)      KPGM1  = 5.*^3;      KPGM = 1.0/6.8;       KPGM2  = KPGM1/KPGM ;      PGM   := scalepgm*(KPGM1*PG3-KPGM2*PG2)*Exp[(16.907-5236.7/TEMP)];     (*------------ ENOLASE ------------*)      KEN  = 1/0.585294;       KEN1 = 200*250;      KEN2 = KEN1/KEN;         EN  := scaleen*(KEN1*PG2-KEN2*PEP)*Exp[(19.876-6152.2/TEMP) ];      (* ------------ PYRUVATE KINASE ------------ *)      If[ PHI > 7.21,       pkVM := (300 -90.9*(PHI-7.2))* Exp[(20.610-6379.6/TEMP)]*250/300 ,        pkVM := (300 -113.6*(7.2-PHI))* Exp[(20.610-6379.6/TEMP)]*250/300];         pkKADP = 0.474;        pkKPEP = 0.225;        pkKFDP = 0.005;        pkKATP = 3.39;        pkL0   = 19;          pkDEN1 = MGADP/(pkKADP+MGADP) * PEP/(pkKPEP+PEP);        pkDEN2 = (1+ATP/pkKATP)^4;        pkDEN3 = ((1+PEP/pkKPEP)^4)*((1+FDP/pkKFDP)^4);        PK  := scalepk*pkVM*pkDEN1/(1+pkL0*(pkDEN2/pkDEN3));      (*   ------------ PYRUVATE ------------ *)       KPYR   = 63.8;             PEX   := -scalepex*KPYR*(PYREXT-PYR)*Exp[(14.52096-4501.5/TEMP)];      (*  ------------ LACTATE DEHYDROGENASE ------------ *)      KLDH =44.64;      KLD1 = 308642.2;      KLD2 = KLD1/KLDH ;      LDH :=       scaleldh*(KLD1*PYR*NADH-KLD2*LAC*(NADHT-NADH))*      Exp[(20.237-6267.2/TEMP)];(*  ------------ LACTATE ------------ *)      KLAC   = 12.8;      VLAC   = -KLAC*(LACEXT-LAC);      LEX := scalelex*VLAC*Exp[(14.543-4501.5/TEMP)];      (*------------ AMP-ASE ------------------- *)KAMPAS   := 1.648/(1 + HI/2.5642*^-3 +1.2159*^-6/HI);      AMPase := scaleampase*(KAMPAS*AMP)*Exp[(19.876-6152.2/TEMP)];(*  ------------ ADENOSINE DEAMINASE ------------*)      adaVM :=       36.348/(1+HI/1.995*^-4+3.162*^-5/HI)*Exp[(19.876- 6152.2/TEMP)];      adaKA   = 0.052;       adaKII   = 1.3;      ADA := scaleada*adaVM*ADO/(adaKA+ADO);(*  ------------ ADENOSINE KINASE ------------ *)      akVM := 8.6229/(1+1.636*^-4/HI)*Exp[(19.876-6152.2/TEMP)];      akKMGATP = 0.8;      akKA     = 0.0004;       AK    := scaleak*akVM*ATP/(ATP+akKMGATP)*ADO/(ADO+akKA);      (*  ------------ ADENYLATE KINASE ------------ *)        adkK1 = 0.081;        adkK2 = 0.81;        adkK3 = 22.2;                    adkk0 = 1.0/4.36038;          adkKADK := adkk0*(MG+adkK1)*(MG+adkK3)/(MG+adkK2)/(MG+adkK2);  adkKAP1 = 200*0.272;      adkKAP2 = adkKAP1/adkKADK;        ADK :=       scaleadk*(adkKAP1*ADP^2-adkKAP2*ATP*AMP)*Exp[(19.876-6152.2/TEMP)];(*   ------------ AMP  DEAMINASE ------------ *)      ampdaVM     = 0.01;      ampdaKAMP   = 0.8;        ampdaKIMP = 2.5;      AMPDA :=       scaleampda*ampdaVM*AMP/(ampdaKAMP+AMP)*Exp[(19.876-6152.2/TEMP)];(*   ------------ ATPASE ------------------- *)  katpase :=       0.4149938/(1+HI/3.7342*^-3+8.2714*^-7/HI)*          Exp[(14.543-4501.5/ TEMP)];           ATPase := scaleatpase*katpase*(ATP  );(*  -------- ADENIN-PHOSPHORIBOSYLPYROPHOSPHATE TRANSFERASE -------- *)      adprtVM :=       0.202/(1+HI/3.981*^-5+3.162*^-7/HI)*Exp[(23.356- 7240.2/TEMP)];      adprtKADE   = 2.3*^-3;      adprtKPRPP  = 19.5*^-3;      ADPRT :=       scaleadprt*adprtVM*(ADE/(adprtKADE+ADE))*(PRPP/(PRPP+adprtKPRPP));        (*  --------------GLUCOSE 6 PHOSPHATE DEHYDROGENASE---------- *)            G6PDH  := Block[{ ET= 93.*^-9,                K1  = 1.1*^8,                K2  = .87*^3,                K3  = .26*^8,                K4  = .30*^3,                K5  = .75*^3,                K6  = 2.0*^3,                K7  = 220*^3,                K8  = 11.*^8,                K9  = 10.*^3,                K10 = 14.*^8,                              M1 :=                             K1*K3*K5*K7*K9*1.1631/(1.0+HI/3.867*^-4)*Exp[(14.167-4380.4/TEMP)]*                      ET,                M2 :=                             K2*K4*K6*K8*K10*1.1631/(1.0+HI/3.867*^-4)*            Exp[(14.167-4380.4/TEMP)]*                      ET,                D1 = K2*K9*(K4*K6+K4*K7+K5*K7),                D2 = K1*K9*(K4*K6+K4*K7+K5*K7),                D5 = K2*K10*(K4*K6+K4*K7+K5*K7),                D3 = K3*K5*K7*K9,                D4 = K2*K4*K6*K8,                D6 = K1*K3*(K5*K7+K5*K9+K6*K9+K7*K9),                D7 = K1*K4*K6*K8,                D8 = K3*K5*K7*K10,                D9 = K8*K10*(K2*K4+K2*K5+K2*K6+K4*K6),                D10= K1*K3*K8*(K5+K6),                D11= K3*K8*K10*(K5+K6),                NUM   = (M1*NADP*G6P - M2*GL6P*NADPH)*1.*^-6,                DEN1  = D1+(D2*NADP+D3*G6P+D4*GL6P+D5*NADPH)*1.*^-3,                DEN2  = (D6*NADP*G6P+D7*NADP*GL6P+D8*G6P*NADPH)*1.*^-6,                DEN3  = D9*GL6P*NADPH*1.*^-6 + D10*NADP*G6P*GL6P*1.*^-9,                DEN4  = D11*G6P*GL6P*NADPH*1.*^-9,                 DEN   := DEN1 + DEN2 + DEN3 + DEN4},      scaleg6pd*NUM*3600/DEN/1*^-3];    (*  --------------GLUCONOLACTONE-6-P HYDROLYSIS----------------- *)        pglaseKM   = 0.08;        pglaseVM   = 9.93;        PGLase :=       scalepglase*pglaseVM*GL6P/(pglaseKM + GL6P)*Exp[(14.167-4380.4/TEMP)];(* ------------GLUCONATE 6 PHOSPHATE DEHYDROGENASE-------------- *)       GL6PDH :=   Block[{               K3 = 1.0*^9,               ET   = 2.1*^-6,                K1 = 1.2*^6,                K2 = 4.1*^2,                K4 = 2.6*^4,                K5 = .48*^2,                K6 = .30*^2,                K7 = 6.3*^2,                K8 = .036*^6,                K9 = 8.0*^2,                K10= .45*^6,                K11= 3.0*^2,                K12= 9.9*^6,                M1 := K1*K3*K5*K7*K9*K11*Exp[(17.896-5546.8/TEMP)]*ET,                M2 := K2*K4*K6*K8*K10*K12*Exp[(17.896-5546.8/TEMP)]*ET,                D1 = K2*K9*K11*(K4*K6+K4*K7+K5*K7),                D2 = K1*K9*K11*(K4*K6+K4*K7+K5*K7),                D3 = K3*K5*K7*K9*K11,                D4 = K2*K4*K6*K8*K11,                D5 = K2*K9*K12*(K4*K6+K4*K7+K5*K7),                A1    = K1*K3*(K5*K9*K11+K6*K9*K11),                B1    = K1*K3*(K7*K9*K11+K5*K7*K9),                C1    = K1*K3*(K5*K7*K11),                D6 = A1 + B1 + C1,                D7 = K1*K4*K6*K8*K11,                D8 = K3*K5*K7*K9*K12,                D9 = K2*K4*K6*K8*K10,                D10= K2*K4*K6*K8*K12,                D11= K2*K10*K12*(K4*K6+K4*K7+K5*K7),                D12= K1*K3*K8*K11*(K5+K6),                D13= K1*K3*K5*K7*K10,                D14= K1*K4*K6*K8*K10,                D15= K3*K5*K7*K10*K12,                D16= K8*K10*K12*(K2*K4+K2*K5+K2*K6+ K4*K6),                D17= K1*K3*K8*K10*(K5+K6),                D18= K3*K8*K10*K12*(K5+K6),                        NUM  = M1*NADP*GO6P*(36.7065*^-3)- M2*CO2*RU5P*NADPH*(36.7065*^-6),                DEN1 = D1+(D2*NADP+D3*GO6P+D4*CO2+D5*NADPH)*1.*^-3,                DEN2 = (D6*NADP*GO6P+D7*NADP*CO2+D8*GO6P*NADPH)*1.*^-6,                DEN3 = (D9*CO2*RU5P+D10*CO2*NADPH+D11*RU5P*NADPH)*1.*^-6,                DEN4 = (D12*NADP*GO6P*CO2 + D13*NADP*GO6P*RU5P)*1.*^-9,                DEN5 = (D14*NADP*CO2*RU5P + D15*GO6P*RU5P*NADPH)*1.*^-9,                  DEN6A= D16*CO2*RU5P*NADPH*1.*^-9 ,                DEN6B= D17*NADP*GO6P*CO2*RU5P*1.*^-12,                DEN6 = DEN6A + DEN6B,                DEN7 = D18*GO6P*CO2*RU5P*NADPH*1.*^-12,                DEN  = DEN1 + DEN2 + DEN3 + DEN4 + DEN5 + DEN6 + DEN7 },           scalegl6pd*NUM/DEN*(160.84-39.173*HI+ 4.1322*HI*HI)  ];       (*  --------------------GSSG REDUCTASE------------------------ *)        gssgK3 = 1.0*^8;        gssgK11= 7.0*^3;        gssgET   = 125*^-9;        gssgK1 = .85*^8;        gssgK2 = .51*^3;        gssgK4 = 7.2*^3;        gssgK5 = .81*^3;        gssgK6 = 1.0*^3;        gssgK7 = 1.0*^6;        gssgK8 = .50*^8;        gssgK9 = 1.0*^6;        gssgK10= .50*^8;        gssgK12= 1.0*^8;        gssgM1 =       gssgK1*gssgK3*gssgK5*gssgK7*gssgK9*gssgK11*Exp[15.136-4690.8/TEMP]*          gssgET*15455.6;         gssgM2 =       gssgK2*gssgK4*gssgK6*gssgK8*gssgK10*gssgK12*Exp[15.136-4690.8/TEMP]*          gssgET*15455.6;        gssgD1 =       gssgK2*gssgK9*gssgK11*(gssgK4*gssgK6+gssgK4*gssgK7+gssgK5*gssgK7);        gssgD2 =       gssgK1*gssgK9*gssgK11*(gssgK4*gssgK6+gssgK4*gssgK7+gssgK5*gssgK7);        gssgD3 = gssgK3*gssgK5*gssgK7*gssgK9*gssgK11;        gssgD4 = gssgK2*gssgK4*gssgK6*gssgK8*gssgK11;        gssgD5 =       gssgK2*gssgK9*gssgK12*(gssgK4*gssgK6+gssgK4*gssgK7+gssgK5*gssgK7);        gssgD6 =       gssgK1*gssgK3*(                      gssgK5*gssgK9*gssgK11+gssgK6*gssgK9*gssgK11+gssgK7*gssgK9*gssgK11+                  gssgK5*gssgK7*gssgK9+gssgK5*gssgK7*gssgK11);        gssgD7 = gssgK1*gssgK4*gssgK6*gssgK8*gssgK11;        gssgD8 = gssgK3*gssgK5*gssgK7*gssgK9*gssgK12;        gssgD9 = gssgK2*gssgK4*gssgK6*gssgK8*gssgK10;        gssgD10= gssgK2*gssgK4*gssgK6*gssgK8*gssgK12;        gssgD11=       gssgK2*gssgK10*gssgK12*(gssgK4*gssgK6+gssgK4*gssgK7+gssgK5*gssgK7);        gssgD12= gssgK1*gssgK3*gssgK8*gssgK11*(gssgK5+gssgK6);        gssgD13= gssgK1*gssgK3*gssgK5*gssgK7*gssgK10;        gssgD14= gssgK1*gssgK4*gssgK6*gssgK8*gssgK10;        gssgD15= gssgK3*gssgK5*gssgK7*gssgK10*gssgK12;        gssgD16=       gssgK8*gssgK10*          gssgK12*(gssgK2*gssgK4+gssgK2*gssgK5+gssgK2*gssgK6+gssgK4*gssgK6);        gssgD17= gssgK1*gssgK3*gssgK8*gssgK10*(gssgK5+gssgK6);        gssgD18= gssgK3*gssgK8*gssgK10*gssgK12*(gssgK5+gssgK6);        gssgNUM = gssgM1*NADPH*GSSG - gssgM2*GSH*GSH*NADP;        gssgDEN1=       gssgD1+(gssgD2*NADPH+gssgD3*GSSG+gssgD4*GSH+gssgD5*NADP)*1*^-3;        gssgDEN2= (              gssgD6*NADPH*GSSG+gssgD7*NADPH*GSH+gssgD8*GSSG*NADP)*1*^-6;        gssgDEN3= gssgD9*GSH*GSH*1*^-6 + (gssgD10 + gssgD11)*GSH*NADP*1*^-6;        gssgDEN4= (gssgD12 + gssgD13)*NADPH*GSSG*GSH*1*^-9;        gssgDEN5= (gssgD14*NADPH*GSH*GSH + gssgD15*GSSG*GSH*NADP)*1*^-9;        gssgDEN6=       gssgD16*GSH*GSH*NADP*1*^-9+gssgD17*NADPH*GSSG*GSH*GSH*1*^-12;        gssgDEN7= gssgD18*GSSG*GSH*GSH*NADP*1*^-12;        gssgDEN =       gssgDEN1 + gssgDEN2 + gssgDEN3 + gssgDEN4 + gssgDEN5 + gssgDEN6 +       gssgDEN7;        GSSGR :=       scalegssgr*gssgNUM/gssgDEN*(-2880+902.33*PHI-65.272*PHI*PHI)/233.075; (*  -------------------GSH GLUTATHIONE--------------------------  *)         gshconst := 1.1429*^-3*Exp[(5.0476-1567.2/TEMP)];        GSHR := scalegshr*gshconst*GSH*(-2880+902.33*PHI-65.272*PHI*PHI);        (*  -----------------EPIMERASE REACTIONS---------------------*)        ru5iVF = 1702.296;        ru5iKEQ = 2.57;        ru5iK1 = 0.78;        ru5iK2 = 2.2;         RU5PI :=       scaleru5pi*ru5iVF*(RU5P - R5P/ru5iKEQ)/(ru5iK1+RU5P+ru5iK1/ru5iK2*R5P);         (*  -----------------EPIMERASE REACTION----------------------*)        xu5eVF =4633.56;        xu5eKEQ = 3.00;        xu5eK1 = 0.19;        xu5eK2 = 1.5 ;        XU5PE :=       scalexu5pe*      xu5eVF*(RU5P - X5P/xu5eKEQ)/(xu5eK1+RU5P+xu5eK1/xu5eK2*X5P);    (*  --------------TRANSKETOLASE REACTION--------------------- *)                 tkiKEQ = 1.2;         tkiET := 0.33*^-3          tkiK1 := 2.16*^5*3600.0*^-3;          tkiK4 = 1.56*^5*3600.0*^-3;          tkiK5 = 3.29*^5*3600.0*^-3;           tkiK8 = 4.48*^4*3600.0*^-3;          tkiK2 = 38.0*3600.0;        tkiK3 = 34.0*3600.0;        tkiK6 = 175.0*3600.0;        tkiK7 = 40.0*3600.0;        tkiN1 = tkiK1*tkiK3*tkiK5*tkiK7;        tkiN2 = tkiN1/tkiKEQ;        tkiD1 = tkiK1*tkiK3*(tkiK6+tkiK7);        tkiD3 = tkiK2*tkiK4*(tkiK6+tkiK7);        tkiD5 = tkiK1*tkiK5*(tkiK3+tkiK7);        tkiD7 = tkiK5*tkiK8*(tkiK2+tkiK3);        tkiD2 = tkiK5*tkiK7*(tkiK2+tkiK3);        tkiD4 = tkiK6*tkiK8*(tkiK2+tkiK3);        tkiD6 = tkiK4*tkiK8*(tkiK2+tkiK6);        tkiD8 = tkiK1*tkiK4*(tkiK6+tkiK7);        tkiD =       tkiD1*X5P+tkiD2*R5P+tkiD3*GAP+tkiD4*S7P+tkiD5*X5P*R5P+tkiD6*GAP*S7P+          tkiD7*R5P*S7P+tkiD8*X5P*GAP;        TKI := scaletki*(tkiN1*X5P*R5P-tkiN2*GAP*S7P)*tkiET/tkiD;(* ---------------TRANSKETOLASE REACTION-------------------- *)TKII :=  Block[{ KEQ = 10.3,ET = 0.33*^-3, K1 = 2.16*^5*3600*^-3,               K2 = 38*3600, K3 = 34*3600, K4 = 1.56*^5*3600*^-3,               K5 = 2.24*^5*3600*^-3, K6 = 175*3600, K7 = 40*3600,               K8 = 2.13*^4*3600*^-3, N1 = K1*K3*K5*K7, N2 = N1/KEQ,               D1 = K1*K3*(K6+K7),D2 = K5*K7*(K2+K3), D3 = K2*K4*(K6+K7),               D4 = K6*K8*(K2+K3), D5 = K1*K5*(K3+K7), D6 = K4*K8*(K2+K6),              D7 = K5*K8*(K2+K3), D8 = K1*K4*(K6+K7),         DEN = D1*X5P+D2*E4P+D3*GAP+D4*F6P+D5*X5P*E4P+D6*GAP*F6P+D7*E4P*F6P+                      D8*X5P*GAP },       scaletkii*(N1*X5P*E4P-N2*GAP*F6P)*ET/DEN ];(*   -----------------TRANSALDOLASE REACTION------------------   *)TALD :=   Block[ {                N1 = K1*K3*K5*K7,                N2 = N1/KEQ,                D1 = K1*K3*(K6+K7),                D3 = K2*K4*(K6+K7),                D5 = K1*K5*(K3+K7),                D7 = K5*K8*(K2+K3),                D2 = K5*K7*(K2+K3),                D4 = K6*K8*(K2+K3),                D6 = K4*K8*(K2+K6),                D8 = K1*K4*(K6+K7),        			            DEN = D1*AX+D2*BX+D3*PX+D4*QX+D5*AX*BX+D6*PX*QX+D7*BX*QX+D8*AX*PX,                AX = S7P,                BX = GAP,                PX = E4P,                QX = F6P,                KEQ = 1.05,                ET = 0.69*^-3,                        K1 = 5.8*^5*3600.0*^-3,                K4 = 1.01*^6*3600.0*^-3,                K5 = 4.9*^5*3600.0*^-3,                K8 = 7.9*^4*3600.0*^-3,                K2 = 45.3*3600.0,                K3 = 16.3*3600.0,                K6 = 60.0*3600.0,                K7 = 17.0*3600.0},             scaletald* (N1*AX*BX-N2*PX*QX)*ET/DEN]; (*  -----------------IMPASE REACTION---------------------  *)        KIASE  := 0.09*1.0431/(1.0+HI/2.5642*^-3+1.2159*^-6/HI);           KINO = 25.0;        IMPase :=       scaleimpase*KIASE*IMP/(1.0+INO/KINO)*Exp[14.543-4501.5/TEMP]; (*  ----------NUCLEOSIDE PHOSPHORYLASE------------------  *)        pnpaseKeq = 0.09;     pnpaseKA1  = 1950.0;        pnpaseKA2  = pnpaseKA1/pnpaseKeq;        PNPase :=       scalepnpase*(pnpaseKA1*INO*PI - pnpaseKA2*HX*R1P)*          Exp[14.543-4501.5/TEMP] ;             (*  ----------RIBOMUTASE REACTION------------------------ *)          prmKeq = 13.3;         prmKA1  = 427.59;        prmKA2  = prmKA1/prmKeq;          PRM  :=       scaleprm*(prmKA1*R1P - prmKA2*R5P )*Exp[(14.543-4501.5/TEMP)]; (*  --------------PRPSYN REACTION------------------------ *)PRPPSYN :=  Block[ {                              VM   := 0.5054*1.6548/(1.0+HI/1.0099*^-4+1.8835*^-6/HI),                KATP = .17,                KR5P = .65 ,                                                     			 KEQ = 28.6,                VR = VM/7.5,                KPRPP = 0.09,                KAMP =  0.275},                       scaleprppsyn*VM*VR*(R5P*ATP-PRPP*AMP/KEQ)/(                                  VR*KR5P*ATP+VR*KATP*R5P+ VM*KAMP*PRPP/KEQ+VM*KPRPP*AMP/KEQ+                          VR*R5P*ATP+VM*PRPP*AMP/KEQ)*        Exp[(14.543-4501.5/TEMP)]];      (*   ---------------HGPRT REACTION---------------------------  *)        hgprtVM   = 0.2011;        hgprtKPRPP= 5.*^-3;        hgprtKHX  = .22;        HGPRT :=       scalehgprt*hgprtVM*(PRPP/(PRPP+hgprtKPRPP))*(HX/(HX+hgprtKHX))*          Exp[(14.543-4501.5/TEMP)];             (*   ---------------HYPOXANTHINE TRANSPORT------------------    *)        hxexPM = 37.8;        hxexVM = 151.6;         hxexKM = 0.4;          HXEX :=       scalehxex*(hxexPM*HX + hxexVM*HX/(HX+hxexKM))*      Exp[(14.543-4501.5/TEMP)]; (*   ---------------ADENINE TRANSPORT------------------    *)kmade = 2.6;vmade = 90;ADEEX := scaleadeex*vmade*(ADE/(kmade+ADE)-adeex/(kmade+adeex));(* ------------------ADENOSINE TRANSPORT---------------------- *)vmaex = 61.2;kmaex = 0.13;ADOEX := scaleadoex*vmaex*(ADO/(kmaex+ADO)-adoex/(kmaex+adoex));(*   ---------------INO-TRANSPORT------------------    *)kmino = 0.13;vmino = 61.2;INOEX :=  vmino*(INO/(kmino+INO)-inoex/(kmino+inoex)); (*  --------------LEAK FLUX FOR POTASSIUM-----------------  *)       kPK  = 9.9*^-11*3600;      kKM  = 4;            kFMAXK = 3.115;      kV1 := kPK*SV*Log[RT]/(RT-1)*(KE - RT*KI);      kV2 := kFMAXK*((KE/(kKM+KE)) - (KI*RT/(KI*RT + kKM)));      KLEAK :=       scalekleak*(kV1 + kV2)*(-1.16+0.3*PHI)* Exp[(22.7283-7045.7976/TEMP)];     (*  ---------------LEAK FLUX FOR SODIUM-------------------- *)      PNA = 1.1*^-10*3600;      naKM  = 21.;        FMAXN = 2.8166;        naV1 := PNA*SV*Log[(RT)]/(RT-1)*(NAE - RT*NAI);      naV2 := FMAXN*((NAE/(naKM+NAE)) - (NAI*RT/(NAI*RT + naKM)));      NALEAK :=       scalenaleak*(naV1 + naV2)*(-1.16+0.3*PHI)*Exp[(29.2222-9058.88/TEMP)];(*  ------------------- NA/K PUMP----------------------- *)       PUMP := Block[{        VM  = 2.318/(1+HI/3.7342*^-3+8.2714*^-7/HI) ,                        KSP = 0.1328,                        KS  = 0.0617,                        PSI = 0.7114,                        K1  = 0.0082,                        K2  = 0.0501,                        KNA = 6.2672,                        NUM    = VM*(KE^2 + KSP*KE*PSI*0.5),                        DEN1   = KS*KSP + 2.*KSP*KE + KE^2,                        DEN2   = (KNA/NAI + 1)^3,                        DEN3   = (K1*KS*KSP + K2*(KE^2 + PSI*KSP*KE)),                        DEN    = DEN1 + DEN2*DEN3,                          FATP   = ATP/(ATP+0.04) },               scalepump* FATP*NUM*.5/DEN*Exp[(40.7298-12626.2626/TEMP)]]; scalehk :=1;scalepgi:=1;scalepfk:=1;scaleald:=1;scaletpi:=1;scalegapdh:=1;scalepgk:=1;scaledpgm:=1;scaledpgase:=1;scalepgm:=1;scaleen:=1;scalepk:=1;scalepex:=1;scaleldh:=1;scalelex:=1;scaleampase:=1;scaleada:=1;scaleak:=1;scaleadk:=1;scaleampda:=1;scaleatpase:=1;scaleadprt:=1;scaleg6pd:=1;scalepglase:=1;scalegl6pd:=1;scalegssgr:=1;scalegshr:=1;scaleru5pi:=1;scalexu5pe:=1;scaletki:=1;scaletkii:=1;scaletald:=1;scaleimpase:=1;scalepnpase:=1;scaleprm:=1;scaleprppsyn:=1;scalehgprt:=1;scalehxex:=1;scaleadeex:=1;scaleadoex:=1;scalenaleak:=1;scalekleak:=1;scalepump:=1;DECLARE:=REACTIONS := Table[f[i], {i,1,39}];REACTIONS := Table[f[i], {i,1,39}];f[1] := HK - PGI - G6PDH;(* G6P *)f[2] := PGI - PFK +TALD +TKII; (* F6P *)f[3] := PFK - ALD; (* FDP *)f[4] := ALD - TPI; (* DHAP *)f[5] := ALD + TPI - GAPDH + TKI + TKII - TALD; (* GAP *)f[6] := GAPDH - PGK - DPGM; (* DPG13 *)f[7] := DPGM - DPGase; (* DPG23 *)f[8] := PGK - PGM + DPGase; (* PG3 *)f[9] := PGM  - EN; (* PG2 *)f[10]:= EN - PK; (* PEP *)f[11] := PK - PEX - LDH; (* PYR *)f[12] := LDH - LEX; (* LAC *)f[13] := GAPDH - LDH; (* NADH *)f[14] := G6PDH - PGLase; (* GL6P *)f[15] := PGLase - GL6PDH; (* GO6P *) f[16] := -GSSGR + G6PDH + GL6PDH; (* NADPH *) f[17] := 2*GSSGR - GSHR; (* GSH *)f[18] := GL6PDH - RU5PI - XU5PE; (* RU5P *)f[19] := RU5PI - TKI +PRM - PRPPSYN; (* R5P *)f[20] :=  XU5PE - TKI - TKII; (* X5P *)f[21] := TKI - TALD; (* S7P *)f[22] := TALD - TKII; (* E4P *)f[23] := AMPase - ADA - AK    - ADOEX; (* ADO *)f[24] := ADPRT +AK +ADK - AMPase - AMPDA +PRPPSYN; (* AMP *)f[25] := HK +PFK - PGK - PK +AK - 2*ADK +ATPase  + PUMP;(* ADP *)f[26] := PK +PGK - HK - PFK +ADK - AK -PRPPSYN - ATPase  - PUMP; (* ATP *)f[27] := PRPPSYN - ADPRT - HGPRT; (* PRPP *)f[28] := AMPDA - IMPase +HGPRT; (* IMP *)f[29] := IMPase +ADA - PNPase   -INOEX; (* INO *) f[30] := PNPase - HXEX - HGPRT; (* HX *)f[31] := PNPase - PRM; (* R1P *)f[32] := -ADPRT - ADEEX; (* ADE *)  f[33]:= NALEAK - 3*PUMP; (* NAI *)f[34] := KLEAK + 2*PUMP; (* KI *)  (*  f[35] = -MGATP+(ATP k1atp k2atp MG)/(HI+k2atp+k1atp k2atp MG+            HI khatp MG);  f[36] = -MGADP+(ADP k1adp k2adp MG)/(HI+k2adp+k1adp k2adp MG+HI khadp MG);  f[37] = -MGAMP+(AMP k1amp k2amp MG)/(HI+k2amp+k1amp k2amp MG);  f[38] = -MGDPG23+(DPG23 k1pdg23 MG)/(1+k1pdg23 MG);  f[39] = -MGT+       MG + (AMP k1amp k2amp MG)/(HI+k2amp+            k1amp k2amp MG) + (ADP k1adp k2adp MG)/(HI+k2adp+k1adp k2adp MG+            HI khadp MG) + (ATP k1atp k2atp MG)/(HI+k2atp+k1atp k2atp MG+            HI khatp MG) + (DPG23 k1pdg23 MG)/(1+k1pdg23 MG);    k1atp = 1.39*^4;  khatp = 3.55*^1;  k1adp = 1.32*^4;  khadp = 3.24*^1;  k1amp = 6.01*^1;  k1pdg23 = 5.98^2;  k2atp = 1.08*^-7;  k2adp = 1.2*^-7;  k2amp = 3.24*^-7;    *)  f[35] :=-MGATP+(ATP MG)/(MG+mgatpk); (* MGATP *)f[36] :=-MGADP+(ADP MG)/(MG+mgadpk); (* MGADP *)f[37] := -MGAMP+(AMP MG)/(MG+mgampk); (* MGAMP *)f[38] := -MGDPG23+(DPG23 MG)/(MG+mgdpgk); (* MGDPG23 *)  f[39] :=MG + (AMP MG)/(MG+mgampk) + (ADP MG)/(MG+mgadpk) + (ATP MG)/(MG+            mgatpk) + (DPG23 MG)/(MG+mgdpgk) - MGT; (* MG *)mgatpk = 0.081;mgadpk = 0.81;mgampk = 22.2;mgdpgk = 1.67; 	 metabolites = {G6P, F6P, FDP, DHAP, GAP, DPG13, DPG23, PG3, PG2, PEP, PYR,       LAC, NADH, GL6P, GO6P, NADPH, GSH, RU5P, R5P, X5P, S7P, E4P, ADO, AMP,       ADP, ATP, PRPP, IMP, INO, HX, R1P, ADE, NAI, KI, MGATP, MGADP, MGAMP,       MGDPG23, MG} ;mets = {G6P,F6P,FDP,DHAP,GAP,DPG13,DPG23,PG3,PG2,PEP,PYR,LAC,NADH,GL6P,GO6P,      NADPH,GSH,RU5P,R5P,X5P,S7P,E4P,ADO,AMP,ADP,ATP,PRPP,IMP,INO,HX,R1P,ADE,      NAI,KI};fluxes = {HK, PGI, PFK, ALD, TPI, GAPDH, PGK, DPGM, DPGase, PGM, EN, PK,     PEX,       LDH, LEX, AMPase, ADA, AK, ADK, AMPDA, ATPase, ADPRT, G6PDH, PGLase,       GL6PDH, GSSGR, GSHR, RU5PI, XU5PE, TKI, TKII, TALD, IMPase, PNPase,       PRM, PRPPSYN, HGPRT, HXEX, ADEEX, ADOEX,INOEX,  NALEAK, KLEAK, PUMP};fluxnames = {"HK", "PGI", "PFK", "ALD", "TPI","GAPDH", "PGK", "DPGM",       "DPGase", "PGM", "EN", "PK", "PEX", "LDH", "LEX", "AMPase", "ADA",       "AK", "ADK", "AMPDA", "ATPase", "ADPRT", "G6PDH", "PGLase", "GL6PDH",       "GSSGR", "GSHR", "RU5PI", "XU5PE", "TKI", "TKII", "TALD", "IMPase",       "PNPase", "PRM", "PRPPSYN", "HGPRT", "HXEX","ADEEX", "ADOEX","INOEX",      "NALEAK", "KLEAK", "PUMP"};scale = {scalehk, scalepgi, scalepfk, scaleald, scaletpi, scalegapdh,     scalepgk, scaledpgm, scaledpgase, scalepgm, scaleen, scalepk, scalepex,     scaleldh, scalelex, scaleampase, scaleada, scaleak, scaleadk,     scaleampda,     scaleatpase, scaleadprt, scaleg6pd, scalepglase, scalegl6pd, scalegssgr,     scalegshr, scaleru5pi, scalexu5pe, scaletki, scaletkii, scaletald,     scaleimpase, scalepnpase, scaleprm, scaleprppsyn, scalehgprt, scalehxex,     scaleadeex,scaleadoex,scaleinoex, scalenaleak, scalekleak,     scalepump};<<Graphics`Arrow`;(*   Make a map of the erythrocyte metabolism at the steady state  *)map[ ]:=  Module[{HK, PGI, PFK, ALD,TPI, GAPDH,  PGK, DPGM, DPGase, PGM, EN, PK,       LDH,       PEX, LEX, AMPase, ADA, AK, ADK, AMPDA, ATPase, ADPRT,  G6PDH, PGLase,       GL6PDH, GSSGR, GSHR, RU5PI, XU5PE, TKI, TKII, TALD, IMPase, PNPase,       PRM, PRPPSYN, HGPRT, ADEEX, ADOEX, HXEX,inoex, NALEAK, KLEAK, PUMP,       flux,  roots, nadp,gssg,G6P,F6P,FDP,DHAP,GAP,DPG13,DPG23,PG3,PG2,PEP,      PYR,LAC,NADH,GL6P,GO6P,NADPH,GSH,RU5P,R5P,X5P,S7P,E4P,ADO,AMP,ADP,ATP,      PRPP,IMP,INO,HX,R1P,ADE,NAI,KI,MGATP,MGADP,MGAMP,MGDPG23,MG, graphics,      a1, a2,a2r, a3,a4,a4r, a5, a5r,a6,a6r, a7,a7r, a8, a9, a10, a11, a11r,       a12,a12r, a13,a14,a15, a16,  a17, a18, a19,  a21, a22, a23, a24, a25,      a27,a28,a29, a30,a31, a32,a34,a35,a36,a37,a38,a39,a40, a40r, a41,       a41r,       a42, a43, a44, a45, a200,a202, a203, a204, a205,a250, a260,a270,a360,       a370, a380,a440, a450, a460, a470, a480,a700, a3200, a3300,a3600,       a3700,      a1l, a2l, a3l, a4l,a5l, a6l,f0, f1, f2, f3, f4, f5, f6, f7, f8, f9,       f10, f11, f13, f14, f15, f16,f17, f18,f19,f20,f22, f23, f24, f25,        f26,       f27,f28,f29, f30, f31,f32,f33,f34,f35, f36,f37,f38, f39,f40,f41, f42,       f43,f44,f45,f46,t0,t1, t2, t3, t4, t5, t6, t7, t8, t9,t10, t11, t12,       t13,t22, t23,t24, t25, t26, t27, t28, t29, t30,t31, t32, t33, t34,       t35,       t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47,t270, t280,       t300, t301, t302, t303, t304},        flux = fluxes;    roots = findroots[];    HK = flux[[1]]/.roots; PGI= flux[[2]]/.roots; PFK= flux[[3]]/.roots;     ALD= flux[[4]]/.roots; TPI= flux[[5]]/.roots; GAPDH= flux[[6]]/.roots;     PGK= flux[[7]]/.roots; DPGM= flux[[8]]/.roots; DPGase= flux[[9]]/.roots;     PGM= flux[[10]]/.roots; EN= flux[[11]]/.roots; PK= flux[[12]]/.roots;     PEX= flux[[13]]/.roots; LDH= flux[[14]]/.roots; LEX= flux[[15]]/.roots;     AMPase= flux[[16]]/.roots; ADA= flux[[17]]/.roots;     AK= flux[[18]]/.roots;     ADK= flux[[19]]/.roots; AMPDA= flux[[20]]/.roots;     ATPase= flux[[21]]/.roots; ADPRT= flux[[22]]/.roots;     G6PDH= flux[[23]]/.roots; PGLase= flux[[24]]/.roots;     GL6PDH= flux[[25]]/.roots;GSSGR= flux[[26]]/.roots;     GSHR= flux[[27]]/.roots; R5PI= flux[[28]]/.roots;     XU5PE= flux[[29]]/.roots; TKI= flux[[30]]/.roots;     TKII= flux[[31]]/.roots; TALD= flux[[32]]/.roots;     IMPase= flux[[33]]/.roots; PNPase= flux[[34]]/.roots;     PRM= flux[[35]]/.roots; PRPPSYN= flux[[36]]/.roots;     HGPRT= flux[[37]]/.roots; HXEX= flux[[38]]/.roots;     ADEEX = flux[[39]]/.roots;    	          ADOEX = flux[[40]]/.roots; inoex = flux[[41]]/.roots;    NALEAK = flux[[42]]/.roots; KLEAK = flux[[43]]/.roots;     PUMP  = flux[[44]]/.roots;                    G6P =metabolites[[1]]/.roots; F6P = metabolites[[2]]/.roots;     FDP= metabolites[[3]]/.roots; DHAP= metabolites[[4]]/.roots;     GAP= metabolites[[5]]/.roots; DPG13= metabolites[[6]]/.roots;     DPG23= metabolites[[7]]/.roots; PG3= metabolites[[8]]/.roots;     PG2= metabolites[[9]]/.roots; PEP= metabolites[[10]]/.roots;     PYR= metabolites[[11]]/.roots; LAC= metabolites[[12]]/.roots;     NADH= metabolites[[13]]/.roots; GL6P= metabolites[[14]]/.roots;     GO6P= metabolites[[15]]/.roots; NADPH= metabolites[[16]]/.roots;     GSH= metabolites[[17]]/.roots; RU5P= metabolites[[18]]/.roots;     R5P= metabolites[[19]]/.roots; X5P= metabolites[[20]]/.roots;     S7P= metabolites[[21]]/.roots; E4P= metabolites[[22]]/.roots;     ADO= metabolites[[23]]/.roots; AMP= metabolites[[24]]/.roots;     ADP= metabolites[[25]]/.roots; ATP= metabolites[[26]]/.roots ;     PRPP= metabolites[[27]]/.roots; IMP= metabolites[[28]]/.roots;     INO= metabolites[[29]]/.roots; HX= metabolites[[30]]/.roots;     R1P= metabolites[[31]]/.roots; ADE= metabolites[[32]]/.roots;    		       NAI = metabolites[[33]]/.roots; KI = metabolites[[34]]/.roots;    gssg = GSSG/.roots; nadp = NADP/.roots;    h =  Graphics[Line[{{-10,2}, {60, 2}}]];    h2 =  Graphics[Line[{{-10,2}, {-10, 30}}]];    h3 =  Graphics[Line[{{-10,30}, {60, 30}}]];    h4 =  Graphics[Line[{{60,2}, {60, 30}}]];						    a1= Graphics[Arrow[{0,0}, {0, -2},HeadScaling->Relative]];    a2= Graphics[Arrow[{0,-3}, {0, -5},HeadScaling->Relative]];    a2r= Graphics[Arrow[{0, -5},{0,-3},HeadScaling->Relative]];    a3= Graphics[Arrow[{0,-6}, {0, -8},HeadScaling->Relative]];    a4= Graphics[Arrow[{0,-9}, {0, -11},HeadScaling->Relative]];    a4r= Graphics[Arrow[{0, -11},{0,-9},HeadScaling->Relative]];    a5= Graphics[        Arrow[{0,-9}, {-3.5, -9},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]];    a5r= Graphics[        Arrow[{-3.5, -9},{0,-9},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]];    a6= Graphics[        Arrow[{-3.5,-9}, {0, -11},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]];    a6r= Graphics[        Arrow[{0, -11},{-3.5,-9},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]];        a7= Graphics[Arrow[{0,-12}, {0, -14},HeadScaling->Relative]];    a7r= Graphics[Arrow[{0, -14},{0,-12},HeadScaling->Relative]];    a8= Graphics[Arrow[{0,-15}, {0, -17},HeadScaling->Relative]];    a9= Graphics[        Arrow[{0,-15}, {-3.5, -15},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]];    a10= Graphics[        Arrow[{-3.5,-15}, {0, -17},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]];        a11= Graphics[Arrow[{0,-18}, {0, -20},HeadScaling->Relative]];    a11r= Graphics[Arrow[{0, -20},{0,-18},HeadScaling->Relative]];    a12= Graphics[Arrow[{0,-21}, {0, -23},HeadScaling->Relative]];    a12r= Graphics[Arrow[{0, -23},{0,-21},HeadScaling->Relative]];    a13= Graphics[Arrow[{0,-24}, {0, -26},HeadScaling->Relative]];    a14= Graphics[Arrow[{0,-27}, {0, -29},HeadScaling->Relative]];    a15= Graphics[        Arrow[{2.5,-26.5}, {4, -26.5},HeadScaling->Absolute,           HeadWidth->0.22,           HeadLength->10]];    a16= Graphics[        Arrow[{2.5,-30}, {4, -30},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]];    		(* revisions start *)    (* PPP *)        a17= Graphics[        Arrow[{2,-2.5}, {3.5, -2.5},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]];(*G6PDH*)        a18= Graphics[        Arrow[{8,-2.5}, {9.5, -2.5},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]];(*PGLase*)        a19= Graphics[        Arrow[{12,-2.5}, {12, -4.75},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]];(*GL6PDH*)    		    a40= Graphics[        Arrow[{12,-5.25}, {16, -7.25},HeadScaling->Absolute,           HeadWidth->0.22,           HeadLength->10]]; (* R5PI *)        a40r= Graphics[        Arrow[{16,-7.25}, {12, -5.25},HeadScaling->Absolute,           HeadWidth->0.22,           HeadLength->10]]; (* R5PI *)        a41= Graphics[        Arrow[{12,-5.25}, {7.5, -7.25},HeadScaling->Absolute,           HeadWidth->0.22, HeadLength->10]]; (* XU5PE *)        a41r= Graphics[        Arrow[{7.5,-7.25}, {12, -5.25},HeadScaling->Absolute,           HeadWidth->0.22, HeadLength->10]]; (* XU5PE *)        a42= Graphics[        Arrow[{7.5,-7.75}, {15.5, -9.75},HeadScaling->Absolute,           HeadWidth->0.22, HeadLength->10]];	(* TK? *)			    a43= Graphics[        Arrow[{15.5,-7.75}, {7.5, -9.75},HeadScaling->Absolute,           HeadWidth->0.22, HeadLength->10]];	(* TK? *)	    a44= Graphics[        Arrow[{7.5,-10.25}, {15.5, -12.25},HeadScaling->Absolute,           HeadWidth->0.22, HeadLength->10]];	(* TK? *)	    a45= Graphics[        Arrow[{15.5,-10.25}, {7.5, -12.25},HeadScaling->Absolute,           HeadWidth->0.22, HeadLength->10]];	(* TK? *)		    		    	(* non-ox to glyc *)			    a1l= Graphics[Line[{{6,-5.5}, {6, -7}}]];	(* TK? *)			    a2l= Graphics[        Arrow[{6,-5.5}, {2, -5.5},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]];(* TK? *)	    a3l= Graphics[Line[{{6,-12}, {6, -11.5}}]];	(* TK? *)	    a4l =       Graphics[Arrow[{6,-11.5}, {2, -11.5},HeadScaling->Absolute,           HeadWidth->0.22, HeadLength->10]];(* TK? *)	    a5l = Graphics[Line[{{4,-11.5}, {4, -5.5}}]];	(* TK? *)	    		(* end non-ox to glyc *)    																		    a21 =       Graphics[Arrow[{28.5,-2.75}, {23.5, -4.75},HeadScaling->Absolute,           HeadWidth->0.22, HeadLength->10]];  (* AK *)        a22 =Graphics[        Arrow[{23.5,-2.75}, {28.5, -4.75},HeadScaling->Absolute,           HeadWidth->0.22, HeadLength->10]]; (* AK *)        a23 =Graphics[        Arrow[{35,-3.25}, {32, -2.75},HeadScaling->Absolute,           HeadWidth->0.22,           HeadLength->10]];  (* ADK *)        a24 =Graphics[        Arrow[{35,-3.25}, {32, -4.75},HeadScaling->Absolute,           HeadWidth->0.22,           HeadLength->10]];  (* ADK *)	    a25 =Graphics[        Arrow[{35,-3.25}, {37, -3.25},HeadScaling->Absolute,           HeadWidth->0.22,           HeadLength->10]];  (* ADK *)			    a6l = Graphics[Line[{{40,-7.25}, {40, -5}}]];	(* AMPase *)	    a700 =       Graphics[Arrow[{40,-5}, {33, -5},HeadScaling->Absolute,           HeadWidth->0.22, HeadLength->10]];  (* AMPase *)					        a31 = Graphics[Arrow[{40,-10.5}, {40, -12},HeadScaling->Relative]]; (*        PNPase *)		    a32 = Graphics[Arrow[{40,-12}, {40, -10.5},HeadScaling->Relative]]; (*        PNPase *)		    a28 = Graphics[Arrow[{40,-8}, {40, -9.5},HeadScaling->Relative]]; (*       for ADA *)		    a34 = Graphics[Arrow[{22,-15.5}, {22, -17},HeadScaling->Relative]]; (*       for PRM *)        a35 = Graphics[Arrow[{22,-14.5}, {22, -13},HeadScaling->Relative]]; (*       for PRPPSYN *)        a360 = Graphics[ Line[{{32,-12.5},{30,-12.5}}]];(*  HGPRT *)        a370 = Graphics[ Line[{{38,-12.5},{30,-12.5}}]];(*  HGPRT *)        a380 =       Graphics[Arrow[{30,-12.5}, {30, -10.5},HeadScaling->Absolute,           HeadWidth->0.22, HeadLength->10]]; (*  HGPRT *)        a27 =Graphics[        Arrow[{30,-2}, {30, 0},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]]; (*  ATPase *)        a29 = Graphics[        Arrow[{30,-5.5}, {30, -9.5},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]]; (*  AMPDA *)        a30 = Graphics[        Arrow[{32,-10}, {38, -10},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]]; (*  IMPase *)     a440 = Graphics[ Line[{{22,-12},{22,-10.5}}]];(* ADPRT *)        a450 = Graphics[ Line[{{22,-8},{22,-10.5}}]];(* ADPRT *)        a460 = Graphics[ Line[{{22,-10},{27,-10}}]];(* ADPRT *)        a470 = Graphics[ Line[{{27,-10},{27,-5}}]];(* ADPRT *)				    a480 =       Graphics[Arrow[{27,-5}, {28, -5},HeadScaling->Absolute,           HeadWidth->0.22, HeadLength->10]]; (* ADPRT *)        a250 =Graphics[        Arrow[{44,-7.5}, {48, -7.5},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]]; (* ADOEX *)    		    a280 =Graphics[        Arrow[{48, -7.5},{44,-7.5}, HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]]; (* ADOEX *)        a260 =Graphics[        Arrow[{44,-12.5}, {48, -12.5},HeadScaling->Absolute,           HeadWidth->0.22,           HeadLength->10]]; (* HXEX *)    		    a290 =Graphics[        Arrow[ {48, -12.5},{44,-12.5},HeadScaling->Absolute,           HeadWidth->0.22,           HeadLength->10]]; (* HXEX *)        a270 =Graphics[        Arrow[{44,-10}, {48, -10},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]]; (* INOEX *)    		    a300 =Graphics[        Arrow[ {48, -10},{44,-10},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]]; (* INOEX *)    		    a3200 = Graphics[ Line[{{20,-7.5},{19,-7.5}}]]; 			(* ADEEX *)	    a3300 =       Graphics[Arrow[{19,-7.5}, {19, 2},HeadScaling->Absolute,           HeadWidth->0.22, HeadLength->10]]; (* ADEEX *)					        						(* NA/K *)        a36 =  Graphics[        Arrow[{23,-31}, {21.5, -31},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]]; (* PUMP *)        a37 =        Graphics[Arrow[{18.5,-31}, {16, -31},HeadScaling->Absolute,           HeadWidth->0.22, HeadLength->10]];  (* PUMP *)        a3600 =  Graphics[        Arrow[{20,-30.5}, {20, -29},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]]; (* PUMP *)        a3700 =  Graphics[        Arrow[{20,-31.5}, {20, -33},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]];  (* PUMP *)		    a38 =        Graphics[Arrow[{30,-31}, {30, -29},HeadScaling->Absolute,           HeadWidth->0.22, HeadLength->10]]; (* NA LEAK *)		    a39  =       Graphics[Arrow[{36,-31}, {36, -29},HeadScaling->Absolute,           HeadWidth->0.22, HeadLength->10]];			(* K LEAK *)    		    a200=Graphics[Line[{{8,0}, {10, 0}}]];(*GSSGR+others*)        a202 =       Graphics[        Arrow[{10,0}, {11, -1},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]];(*GSSGR+others*)        a203 = Graphics[        Arrow[{10,0}, {11, 1},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]];(*GSSGR+others*)        a204 = Graphics[        Arrow[{8,0}, {7, -1},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]];(*GSSGR+others*)        a205 = Graphics[        Arrow[ {8, 0},{7,1},HeadScaling->Absolute, HeadWidth->0.22,           HeadLength->10]];(*GSSGR+others*)						    (* revisions end *)        f0=Graphics[RGBColor[1,0,0],Text[StyleForm["HK",FontSize->12], {0,1}]];    f1=Graphics[Text[StyleForm["HK"N[HK,2],FontSize->12], {0,-1}, {-1,0}]];    f2=Graphics[        Text[StyleForm["PGI" N[PGI,2],FontSize->12], {0,-4}, {-1,0}]];    f3=Graphics[Text[StyleForm["PFK"N[PFK,2],FontSize->12], {0,-7}, {-1,0}]];    f4=Graphics[        Text[StyleForm["ALD" N[ALD,2],FontSize->12], {0,-10}, {-1,0}]];    f5=Graphics[        Text[StyleForm["TPI" N[TPI,2],FontSize->12], {-3.5,-10}, {-1,0}]];    f6=Graphics[        Text[StyleForm["GAPDH" N[GAPDH,2],FontSize->12], {0,-13}, {-1,0}]];    f7=Graphics[        Text[StyleForm["PGK" N[PGK,2],FontSize->12], {0,-16}, {-1,0}]];    f8=Graphics[        Text[StyleForm["PGM" N[PGM,2],FontSize->12], {0,-19}, {-1,0}]];    f9=Graphics[Text[StyleForm["EN" N[EN,2],FontSize->12], {0,-22}, {-1,0}]];    f10=Graphics[Text[StyleForm["PK"N[PK,2],FontSize->12], {0,-25}, {-1,0}]];    f11=Graphics[        Text[StyleForm["LDH" N[LDH,2],FontSize->12], {0,-28}, {-1,0}]];        f13=Graphics[Text[StyleForm["G6PDH" N[G6PDH,2],FontSize->11], {3,-2}]];    f14=Graphics[Text[StyleForm["PGLase" N[PGLase,2],FontSize->11], {9,-2}]];    f15=Graphics[        Text[StyleForm["GL6PDH" N[GL6PDH,2],FontSize->11], {11.5,-3.5}]];    f16=Graphics[Text[StyleForm["GSSGR" N[GSSGR,2],FontSize->11], {9,0.5}]];    f44	=Graphics[Text[StyleForm["GSHR" N[GSHR,2],FontSize->11], {9,-0.5}]];    									    f17=Graphics[Text[StyleForm["ADK"N[ADK,2],FontSize->12], {34,-3}]];        f19=Graphics[Text[StyleForm["AK"N[AK,2],FontSize->12], {26,-3}]];    f20=Graphics[Text[StyleForm["ADA"N[ADA,2],FontSize->12], {40,-8.75}]];    		    f21=Graphics[        Text[StyleForm["AEX"N[AEX,2],FontSize->12], {36,-7},{-1,0}]];    f22=Graphics[Text[StyleForm["PEX"N[PEX,2],FontSize->12], {3,-26}]];     f23=Graphics[Text[StyleForm["LEX"N[LEX,2],FontSize->12], {3,-29}]];    f24=Graphics[Text[StyleForm["DPGM"N[DPGM,2],FontSize->12], {-2.5,-14}]];    f25=Graphics[        Text[StyleForm["DPGase"N[DPGase,2],FontSize->12], {-2,-16.5}]];    								    f26=Graphics[Text[StyleForm["AMPDA"N[ADPRT,2],FontSize->12], {30,-7}]];    f35=Graphics[Text[StyleForm["HGPRT"N[HGPRT,2],FontSize->12], {30,-12}]];    f29=Graphics[Text[StyleForm["ADPRT"N[ADPRT,2],FontSize->12], {22,-9.5}]];    f30=Graphics[Text[StyleForm["AMPase"N[AMPase,2],FontSize->12], {40,-6}]];    f32=Graphics[Text[StyleForm["HXEX"N[HXEX,2],FontSize->12], {46,-12}]];    f27=Graphics[        Text[StyleForm["ATPase"N[ATPase,2],FontSize->12], {30,-1.5}]];    f18=Graphics[        Text[StyleForm["IMPase"N[IMPase,2],FontSize->12], {35,-9.5}]];        f31=Graphics[        Text[StyleForm["PNPase"N[PNPase,2],FontSize->12], {40,-11.25}]];    f33=Graphics[Text[StyleForm["PRM"N[PRM,2],FontSize->12], {22,-16.25}]];    f34=Graphics[        Text[StyleForm["PRPPSYN"N[PRPPSYN,2],FontSize->12], {22,-13.75}]];    		    f28=Graphics[Text[StyleForm["ADEEX"N[ADEEX,2],FontSize->12], {19,0}]];    f45=Graphics[Text[StyleForm["INOEX"N[inoex,2],FontSize->12], {46,-9.5}]];    f46=Graphics[        Text[StyleForm["ADOEX"N[ADOEX,2],FontSize->12], {46,-7}]];									    f36=Graphics[        Text[StyleForm["NALEAK" N[NALEAK,2],FontSize->12], {30,-31}]];    f37=Graphics[Text[StyleForm["KLEAK" N[KLEAK,2],FontSize->12], {36,-31}]];    f38=Graphics[Text[StyleForm["PUMP" N[PUMP,2],FontSize->12], {20,-31}]];        f39=Graphics[        Text[StyleForm["XU5PE" N[XU5PE,2],FontSize->12], {8.5,-6.25}]];    f40=Graphics[Text[StyleForm["R5PI" N[R5PI,2],FontSize->12], {15,-6.25}]];    f41=Graphics[Text[StyleForm["TK" N[TKI,2],FontSize->12], {11.5,-8.5}]];    f42=Graphics[        Text[StyleForm["TK" N[TKII,2],FontSize->12], {11.5,-11}]];								    f43=Graphics[Text[StyleForm["TALD" N[TALD,2],FontSize->12], {4,-8}]];				    					    t0=Graphics[RGBColor[0,1,0],Text[StyleForm["GLC",FontSize->12], {0,1}]];    t1=Graphics[Text[StyleForm["GLC"N[GLC,2],FontSize->12], {0,.15}]];    t2=Graphics[Text[StyleForm["G6P"N[G6P,2],FontSize->12], {0,-2.5}]];    t3=Graphics[Text[StyleForm["F6P"N[F6P,2],FontSize->12], {0,-5.5}]];    t4=Graphics[Text[StyleForm["FDP"N[FDP,2],FontSize->12], {0,-8.5}]];    t5=Graphics[Text[StyleForm["DHAP"N[DHAP,2],FontSize->12], {-5,-9}]];    t6=Graphics[Text[StyleForm["GAP"N[GAP,2],FontSize->12], {0,-11.5}]];    t7=Graphics[Text[StyleForm["DPG13"N[DPG13,2],FontSize->12], {0,-14.5}]];    t8=Graphics[Text[StyleForm["DPG23"N[DPG23,2],FontSize->12], {-5,-15}]];    t9=Graphics[Text[StyleForm["PG3"N[PG3,2],FontSize->12], {0,-17.5}]];    t10=Graphics[Text[StyleForm["PG2"N[PG2,2],FontSize->12], {0,-20.5}]];    t11=Graphics[Text[StyleForm["PEP"N[PEP,2],FontSize->12], {0,-23.5}]];    t12=Graphics[Text[StyleForm["PYR"N[PYR,2],FontSize->12], {0,-26.5}]];    t13=Graphics[Text[StyleForm["LAC"N[LAC,2],FontSize->12], {0,-29.5}]];                    t22=Graphics[Text[StyleForm["GL6P"N[GL6P, 2],FontSize->12], {6,-2.5}]];    t23=Graphics[Text[StyleForm["GO6P"N[GO6P, 2],FontSize->12], {12,-2.5}]];    																    t24=Graphics[Text[StyleForm["RU5P"N[RU5P, 2],FontSize->12], {12,-5}]];    t25=Graphics[Text[StyleForm["X5P"N[X5P, 2],FontSize->12], {7,-7.5}]];	    t26=Graphics[Text[StyleForm["R5P"N[R5P, 2],FontSize->12], {16,-7.5}]];    t27=Graphics[Text[StyleForm["S7P"N[S7P, 2],FontSize->12], {7,-10}]];    t28=Graphics[Text[StyleForm["GAP",FontSize->12], {16,-10}]];								    t29=Graphics[Text[StyleForm["E4P"N[E4P, 2],FontSize->12], {7,-12.5}]];    t30=Graphics[Text[StyleForm["F6P",FontSize->12], {16,-12.5}]];    t31=Graphics[        Text[StyleForm["ADO"N[ADO, 2],FontSize->12], {22,-2.5}]];								        t32=Graphics[Text[StyleForm["ATP"N[ATP,2],FontSize->12], {30,-2.5}]];    t33=Graphics[Text[StyleForm["ADP"N[ADP,2],FontSize->12], {22,-5}]];    t34 =Graphics[        Text[StyleForm["ADP"2*N[ADP,2],FontSize->12], {40,-3.25}]];		    t35=Graphics[Text[StyleForm["AMP"N[AMP,2],FontSize->12], {30,-5}]];    t36=Graphics[Text[StyleForm["ADE"N[ADE, 2],FontSize->12], {22,-7.5}]];    t37=Graphics[Text[StyleForm["IMP"N[IMP, 2],FontSize->12], {30,-10}]];    t38=Graphics[Text[StyleForm["ADO"N[ADO, 2],FontSize->12], {40,-7.5}]];		    t39=Graphics[Text[StyleForm["INO"N[INO, 2],FontSize->12], {40,-10}]];    t40=Graphics[Text[StyleForm["PRPP"N[PRPP, 2],FontSize->12], {22,-12.5}]];    t41=Graphics[Text[StyleForm["HX"N[HX, 2],FontSize->12], {40,-12.5}]];    																																										    t44=Graphics[Text[StyleForm["NADPH"N[NADPH, 2],FontSize->12], {13,-1}]];    t45=Graphics[Text[StyleForm["NADP"N[nadp, 2],FontSize->12], {6,-1}]];    t46=Graphics[Text[StyleForm["GSH"N[GSH, 2],FontSize->12], {6,1}]];    t47=Graphics[Text[StyleForm["GSSG"N[gssg, 2],FontSize->12], {13,1}]];    								    t270=Graphics[Text[StyleForm["R1P"N[R1P, 2],FontSize->12], {22,-17.5}]];    t280=Graphics[Text[StyleForm["R5P"N[R5P, 2],FontSize->12], {22,-15}]];    t300 =Graphics[Text[StyleForm["ATP",FontSize->12], {24,-31}]];    t301 =Graphics[Text[StyleForm["ADP",FontSize->12], {15,-31}]];    t302 =Graphics[Text[StyleForm["3 Na",FontSize->12], {20,-28}]];    t303 =Graphics[Text[StyleForm["2 K",FontSize->12], {20,-34}]];    t304 =Graphics[Text[StyleForm["ADP",FontSize->12], {30,0.5}]];						    t42=Graphics[Text[StyleForm["NAI"N[NAI, 2],FontSize->12], {30,-30}]];    t43=Graphics[Text[StyleForm["KI"N[KI, 2],FontSize->12], {36,-30}]];        graphics = { a1, a2,a2r, a3,a4,a4r, a5, a5r,a6,a6r, a7,a7r, a8, a9, a10,         a11, a11r, a12,a12r, a13,a14,a15, a16,  a17, a18, a19,  a21, a22,         a23, a24, a25,a27,a28,a29, a30,a31, a32,a34,a35,a36,a37,a38,a39,a40,         a40r, a41, a41r, a42, a43, a44, a45, a200,a202, a203, a204, a205,        a250, a260,a270,a280, a290, a300,a360, a370, a380,a440, a450, a460,         a470, a480,a700, a3200, a3300,a3600, a3700,a1l, a2l, a3l, a4l,a5l,         a6l,f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f13, f14, f15,         f16,f17, f18,f19,f20,f22, f23, f24, f25,  f26, f27,f28,f29, f30, f31,        f32,f33,f34,f35, f36,f37,f38, f39,f40,f41, f42, f43,f44,f45,f46,t0,        t1, t2, t3, t4, t5, t6, t7, t8, t9,t10, t11, t12, t13,t22, t23,t24,         t25, t26, t27, t28, t29, t30,t31, t32, t33, t34, t35, t36, t37, t38,         t39, t40, t41, t42, t43, t44, t45, t46, t47,t270, t280, t300, t301,         t302, t303, t304};    Show[graphics, PlotRange->All,       ImageSize->{1700,1200}];  ]; <<Graphics`MultipleListPlot`;<< Graphics`Legend`;(*******************************************************       Decrease the activity of an enzyme    Usage:  *********************************************************)deficientcell :=     Module[{ENZYME, value, factor},      		ENZYME =         Input[        "Which enzyme should be deficient? (use the enzyme palette) \n For \example, for a cell with deficient Pyruvate Kinase activity, enter: PK"];      		value =         Input[        "What fraction of normal activity should the cell have? \n For a cell \\\\\with 60% normal activity, enter: 0.6"];      REACTIONS=setscale[ENZYME, value];      		DECLARE; ];mandeficientcell[ENZYME_,value_]:=    Module[{factor},REACTIONS=setscale[ENZYME,value];      DECLARE;];(*******************************************************       Find the STEADY STATE concentrations of the metabolites    x is the list of dynamic mass balances    Usage:      a list of substitutions is returned   *********************************************************)findroots[      i_:2000,damp_:1 ] :=                       Module[ { rxns, iclist},      		rxns = REACTIONS;      				      iclist = BUMP*{0.066,0.0272,0.01386,0.147,0.00669,0.000228,4.65,0.0839,            0.01226,0.02087,0.062,1.398,0.030592,0.001759,0.0374,0.0659,          3.312,            0.00493,0.01266,0.01478,0.02398,0.00507,0.0000519,0.148,0.492,            2.401, 0.0136,0.0192,0.0000427, 0.000226,0.0117,0.00103, 14.135,            139.882,1.7835,0.1097,0.00155,0.5714,0.233};           FindRoot[ {rxns[[1]] ==0, rxns[[2]]==0, rxns[[3]]==0,                                     rxns[[4]]==0, rxns[[5]] ==0,           rxns[[6]]==0,                                     rxns[[7]]==0, rxns[[8]]==0,           rxns[[9]]==0,                                     rxns[[10]]==0,rxns[[11]] ==0,          rxns[[12]]==0,                                     rxns[[13]]==0, rxns[[14]]==0,           rxns[[15]] ==0,                                     rxns[[16]]==0, rxns[[17]]==0,           rxns[[18]]==0,                                    rxns[[19]]==0, rxns[[20]]==0,          rxns[[21]] ==0,                                     rxns[[22]]==0, rxns[[23]]==0,           rxns[[24]]==0,                                     rxns[[25]] ==0, rxns[[26]]==0,           rxns[[27]]==0,                                     rxns[[28]]==0, rxns[[29]]==0,           rxns[[30]]==0,                                     rxns[[31]] ==0, rxns[[32]]==0,           rxns[[33]]==0,                                    rxns[[34]] ==0,rxns[[35]] ==0,           rxns[[36]]==0, rxns[[37]]==0, rxns[[38]]==0, rxns[[39]]==0},{G6P,          iclist[[1]]},{F6P,iclist[[2]]},{FDP,iclist[[3]]},{DHAP,          iclist[[4]]},{GAP,iclist[[5]]},{DPG13,iclist[[6]]},{DPG23,          iclist[[7]]},{PG3,iclist[[8]]},{PG2,iclist[[9]]},{PEP,          iclist[[10]]},{PYR,iclist[[11]]},{LAC,iclist[[12]]},{NADH,          iclist[[13]]},{GL6P,iclist[[14]]},{GO6P,iclist[[15]]},{NADPH,          iclist[[16]]},{GSH,iclist[[17]]},{RU5P,iclist[[18]]},{R5P,          iclist[[19]]},{X5P,iclist[[20]]},{S7P,iclist[[21]]},{E4P,          iclist[[22]]},{ADO,iclist[[23]]},{AMP,iclist[[24]]},{ADP,          iclist[[25]]},{ATP,iclist[[26]]},{PRPP, iclist[[27]]},{IMP,          iclist[[28]]},{INO,iclist[[29]]},{HX, iclist[[30]]},{R1P,          iclist[[31]]},{ADE,iclist[[32]]},{ NAI,iclist[[33]] },{KI ,          iclist[[34]] },{MGATP,iclist[[35]]},{MGADP,iclist[[36]]},{MGAMP,          iclist[[37]]},{MGDPG23,iclist[[38]]},{MG,iclist[[39]]},          MaxIterations->i, DampingFactor->damp ] ]; (*********************************************************       x is the reaction list    Usage: tmet  = tsub[metabolite]        returns a list of time dependent metabolites        this is used when the differential equations are solved         	tsub[x___] := Table[ x[[i]]->x[[i]][t],{i, 1,Length[x]}] ;  *********************************************************)tsub[x_] :=     Map[#->#[t]&, x];(*********************************************************       make a new list of reactions of length n  *********************************************************)list[n_]:=    Module[{g,i}, Table[g[i], {i,1,n}]];(*********************************************************            OUTDATED MODULE -- BUT STILL BEING USED FOR: compare[]    x is the reaction list    z is the enzyme that needs to be changed -        n is the value of the new scaling factor    y is the list of scaling factors    z and n are optional, if they are not specified,                     everything will be scaled to 1      Usage: reactionset =                             subreactions["fluxname" ,number, REACTIONS, scale] --                             this can also be used with fluxes      returns a list of reactions with the value of 'z' set to 'n' and all \others                             set to 1  *********************************************************)subreactions[      z_:HK, n_:1,x__:REACTIONS,y__:scale]:=                          Module[{i,rxns,  r,s, subscale,q,g, k, scalename},       subscale =list[Length[y]];       scalename =pickscale[z];      Do[If[ y[[q]] === scalename, subscale[[q]] = y[[q]]->n,                                   subscale[[q]] = y[[q]]->1],  {q, 1,           Length[y]}];      rxns = list[Length[x]];      Do[rxns[[i]] = x[[i]]/.subscale, {i,1,Length[x]}];      rxns];(*********************************************************            OUTDATED MODULE     x is the single flux    z is the specific scale name    n is the value of the new scaling factor    y is the list of scaling factors    z and n are optional, if they are not specified,                     everything will be scaled to 1      Usage: newflux =                             subsingle[HK, specific scale, number, scale] -- this can                             also be used with fluxes      returns the single flux, 'x',                     with the value of 'z' set to 'n' and all others set to 1  *********************************************************)subsingle[x__,       z_:scalehk, n_:1,y__:scale]:=                          Module[{i,flux,  r,s, subscale,q,g, k},       subscale =list[Length[y]];       Do[If[ y[[q]] === z, subscale[[q]] = y[[q]]->n,          subscale[[q]] = y[[q]]->1],  { q, 1, Length[y]}];      flux = x/.subscale;      flux];(*********************************************************         Find the solution for the time dependent Diff Eq's      x is the list of mass balances with the scaling factor substituted      n is the amount of time       ic is the ORDERED list of initial conditions:         y is the list of metabolites      Usage: sol = solution[reactionset, n, ic, metabolites]       returns an interpolating function for the time dependent metabolites  *********************************************************)solution [x__,      n_,  ic__:initial, y__:metabolites]:=                          Module[ {set, counter, dummy, tmet, eq, i,realic},       			If[Length[ic] =!= Length[y],          Print["Initial conditions don't correspond to metabolites"]];      		set = list[2*Length[x]];      		eq = list[Length[x]];          tmet = list[Length[x]];         tmet = tsub[y];      		realic = fixmg[ic];           Do[eq[[i]] = x[[i]]/.tmet, {i,1,Length[x]}];		                                Do[set[[counter]] = (eq[[counter]] == y[[counter]]'[t]), { counter, 1,           Length[x]-5}];      		Do[         set[[Length[x] -p]] = ( D[ eq[[Length[x]-p]], t]  == 0 ), {p, 0,           4}];       	counter = Length[x];      		Do[ counter++;         set[[counter]] = (y[[dummy]][0] == realic[[dummy]]), { dummy, 1,          Length[x]}];       			NDSolve[set,  y, {t, 0.000000000001, n},         WorkingPrecision->WORKINGPRECISION, AccuracyGoal->ACCURACYGOAL,         MaxSteps->MAXSTEPS ]];(*********************************************************       Plot results from Diff Eq's    x is the solution of the Diff Eq's -- see the 'solution' module    n is the amount of time    y is the list of metabolites     sec and third are the solutions for the high and low initial conditions    Usage:  *********************************************************)plotting[x_,        n_, y__:metabolites]:=                       Module[ {j, group1,subgroup, dummy, max},       				group1 = list[Length[y]] ;max = list[Length[y]];      subgroup = list[Length[y]];       Do[         group1[[j]] =                   Partition[ Flatten[ Table[{t, Evaluate[y[[j]][t]/.x]}, {t, 0, n}]] ,            2];subgroup[[j]] =            Table[ Evaluate[y[[j]][t]/.x], {t, 0, n}], {j, 1, Length[y]}];      	Do[ max[[dummy]] = Max[ subgroup[[dummy]]], {dummy, 1, Length[y]}];      			Do[         ListPlot[ group1[[dummy]],PlotLabel->y[[dummy]], Axes->True,           PlotJoined->True,ImageSize->72*2.5,           PlotRange->{0, 1.1*max[[dummy]]}], {dummy, 1, Length[y]}] ];(*********************************************************            Make a pooled metabolite phase plane     time is the time interval    met and met2 are the metabolites    ic is the list of initial conditions    y is the list of metabolites    Usage:   *********************************************************)altphaseplane[        n_,met1_, met2_, ic1_:0, y__:metabolites]:=                           Module[{  highgroup, hourhighgroup,  highset,hourhighset,    label,         highsol,                                 plot, rxn, increment,  tmetgroup1,       tmetgroup2,        label1, label2,  first, hour, rest, power, dummy, timelist,loop,t0},      rxn = REACTIONS;		      If[ ( Length[met1]>3)|| (Length[met2]>3), label = {"met1", "met2"};         Print[        "The size of either met1 or met2 is too large to label the plot."];,      label = {newlabel[met1], newlabel[met2]};];      tmetgroup1=  met1/.tsub[y];      tmetgroup2= met2/.tsub[y];                        dummy = 0;      loop = 0;      t0 = 1/3600;      While[dummy<n,        dummy=N[t0*10^((loop/100)*(Log[10,n]-Log[10,t0]))];        loop++;];      timelist = Table[ N[0], {dummy, 0, loop}];      dummy=0;      loop=1;      t0=1/3600;      While[dummy<n,timelist[[loop]]=N[dummy];        dummy=N[t0*10^((loop/100)*(Log[10,n]-Log[10,t0]))];        loop++;];                  highsol = solution[rxn, n, ic1, y];      		hourhighgroup = list[Length[timelist]];       Do[ hourhighgroup[[dummy]] = {Evaluate[tmetgroup1/.highsol]/.t->                timelist[[dummy]],                                                     Evaluate[tmetgroup2/.highsol/.t->timelist[[dummy]]]}, {dummy, 1,           Length[timelist]}];       hourhighset = Partition[Flatten[hourhighgroup],2];            plot =         MultipleListPlot[ hourhighset,  AxesLabel->label, PlotRange->All,                                     Axes->True,                                                 SymbolShape->{ PlotSymbol[Star, 1.5,Filled->False],              PlotSymbol[Star, 1.5,Filled->False]}];   plot ];	(*********************************************************            Make a pooled metabolite phase plane -- on a LOG10 scale    time is the time interval    met and met2 are the metabolites    ic is the list of initial conditions    y is the list of metabolites    Usage:   *********************************************************)phaseplane[  n_,met1_, met2_, ic1_:0,ic2_:0, y__:metabolites]:=                           Module[{  tenhourhighgroup, highgroup, hourhighgroup,  highset,        hourhighset,tenhourhighset, tenhourhighgroup2, highgroup2,         hourhighgroup2,  highset2,hourhighset2,tenhourhighset2,   label,         highsol, highsol2,                                plot, rxn, increment,  tmetgroup1,         tmetgroup2,  first, hour, tenhour, rest, power, dummy, endhour,         endtenhour,end,t0,loop},      rxn = REACTIONS;		      If[ ( Length[met1]>3)|| (Length[met2]>3), label = {"met1", "met2"};         Print[        "The size of either met1 or met2 is too large to label the plot."];,      label = {newlabel[met1], newlabel[met2]};];      tmetgroup1=  met1/.tsub[y];      tmetgroup2= met2/.tsub[y];            If[n<10,                          Print["Time = ",n," hou\.14rs"];                dummy = 0;        loop = 0;        t0 = 1/3600;        While[dummy<n,          dummy=N[t0*10^((loop/100)*(Log[10,n]-Log[10,t0]))];          loop++;];        rest = Table[ N[0], {dummy, 0, loop}];        dummy=0;        loop=1;        t0=1/3600;        While[dummy<n,rest[[loop]]=N[dummy];          dummy=N[t0*10^((loop/100)*(Log[10,n]-Log[10,t0]))];          loop++;];                end = Length[rest];        Which[(ic1=!= 0) && (ic2 =!=0),           highsol = solution[rxn, n, ic1, y];          		hourhighgroup = list[Length[rest]];           Do[ hourhighgroup[[dummy]] = {Evaluate[                    tmetgroup1/.highsol]/.t\[Rule]rest[[dummy]],                                                             Evaluate[                  tmetgroup2/.highsol/.t\[Rule]rest[[dummy]]]}, {dummy, 1,               end}];           hourhighset = Partition[Flatten[hourhighgroup],2];                    highsol2 = solution[rxn, n, ic2, y];          hourhighgroup2 = list[Length[rest]];                    Do[ hourhighgroup2[[dummy]] = {Evaluate[                    tmetgroup1/.highsol2]/.t\[Rule]rest[[dummy]],                                                             Evaluate[                  tmetgroup2/.highsol2/.t\[Rule]rest[[dummy]]]}, {dummy, 1,               end}];           hourhighset2 = Partition[Flatten[hourhighgroup2],2];                              plot = MultipleListPlot[hourhighset,hourhighset2,                AxesLabel->label, PlotRange->All,              Axes->True,                                           SymbolShape->{ PlotSymbol[Star, 1.5,Filled->False],                  PlotSymbol[Star, 1.5,Filled->False]},              SymbolStyle->{RGBColor[1,0,0],RGBColor[0,1,0]}]; ,          (ic1 =!= 0) &&(ic2 === 0),          highsol = solution[rxn, n, ic1, y];          		hourhighgroup = list[Length[rest]];           Do[ hourhighgroup[[dummy]] = {Evaluate[                    tmetgroup1/.highsol]/.t\[Rule]rest[[dummy]],                                                             Evaluate[                  tmetgroup2/.highsol/.t\[Rule]rest[[dummy]]]}, {dummy, 1,               end}];           hourhighset = Partition[Flatten[hourhighgroup],2];                    		                    plot = MultipleListPlot[ hourhighset,  AxesLabel->label,               PlotRange->All,                                         Axes->True,                                                         SymbolShape->{ PlotSymbol[Star, 1.5,Filled->False]},              SymbolStyle->{RGBColor[1,0,0]}]; , (ic1 ===0)&&(ic2 ===0),           Return [Print[                            "You need to enter at least one set of initial conditions!"]]; ];        plot                                                        ,        		power = Log[10, n];  increment = power/50;         		        hour = Table[ N[10^dummy], {dummy, -16, -1.77, increment}]; (*           minutes not hours *)        		        tenhour = Table[ N[10^dummy], {dummy, -1.77, 0, increment}]; (*           hour not 10 hours *)        		        rest = Table[ N[10^dummy], {dummy, 0, power, increment}];        			endhour =Length[hour];        		endtenhour =Length[tenhour];        			end = Length[rest];        		Which[(ic1=!= 0) && (ic2 =!=0),           highsol = solution[rxn, n, ic1, y];          		hourhighgroup = list[Length[hour]];           Do[ hourhighgroup[[dummy]] = {Evaluate[tmetgroup1/.highsol]/.t->                    hour[[dummy]],                                                             Evaluate[tmetgroup2/.highsol/.t->hour[[dummy]]]}, {dummy, 1,               endhour}];           hourhighset = Partition[Flatten[hourhighgroup],2];          				tenhourhighgroup = list[Length[tenhour]];           Do[ tenhourhighgroup[[dummy]] = {Evaluate[tmetgroup1/.highsol]/.t->                    tenhour[[dummy]],                                                             Evaluate[tmetgroup2/.highsol/.t->tenhour[[dummy]]]}, {dummy,               1, endtenhour}];           tenhourhighset = Partition[Flatten[tenhourhighgroup],2];          		highgroup = list[Length[rest]];           Do[ highgroup[[dummy]] = {Evaluate[tmetgroup1/.highsol]/.t->                    rest[[dummy]],                                                             Evaluate[tmetgroup2/.highsol/.t->rest[[dummy]]]}, {dummy, 1,               end}];           highset = Partition[Flatten[highgroup],2];          			highsol2 = solution[rxn, n, ic2, y];          		hourhighgroup2 = list[Length[hour]];           Do[ hourhighgroup2[[dummy]] = {Evaluate[tmetgroup1/.highsol2]/.t->                    hour[[dummy]],                                                             Evaluate[tmetgroup2/.highsol2/.t->hour[[dummy]]]}, {dummy,             1,               endhour}];           hourhighset2 = Partition[Flatten[hourhighgroup2],2];          				tenhourhighgroup2 = list[Length[tenhour]];                   Do[ tenhourhighgroup2[[dummy]] = {Evaluate[tmetgroup1/.highsol2]/.t->                    tenhour[[dummy]],                                                             Evaluate[tmetgroup2/.highsol2/.t->tenhour[[dummy]]]}, {            dummy,               1, endtenhour}];           tenhourhighset2 = Partition[Flatten[tenhourhighgroup2],2];          		highgroup2 = list[Length[rest]];           Do[ highgroup2[[dummy]] = {Evaluate[tmetgroup1/.highsol2]/.t->                    rest[[dummy]],                                                             Evaluate[tmetgroup2/.highsol2/.t->rest[[dummy]]]}, {dummy,             1,               end}];           highset2 = Partition[Flatten[highgroup2],2];          			          plot = MultipleListPlot[hourhighset,tenhourhighset,highset,              hourhighset2,tenhourhighset2,highset2,  AxesLabel->label,               PlotRange->All,Axes->True,                                           SymbolShape->{ PlotSymbol[Star, 1.5,Filled->False],                  PlotSymbol[Star, 1.5,Filled->False],                  PlotSymbol[Star, 1.5,Filled->False],                  PlotSymbol[Star, 1.5,Filled->False],                  PlotSymbol[Star, 1.5,Filled->False],                  PlotSymbol[Star, 1.5,Filled->False]},              SymbolStyle->{RGBColor[1,0,0],RGBColor[0,1,0], RGBColor[0,0,1],                  RGBColor[1,0,0],RGBColor[0,1,0], RGBColor[0,0,1] }];           If[ n >10,            Print[n,               "  Hours\nRed Points: 0-1 Hour\nGreen Points: 1-10 Hours"],             Print[n, "  Hours \n Red Points: 0-1 hour"]];,          (ic1 =!= 0) &&(ic2 === 0),highsol = solution[rxn, n, ic1, y];          		hourhighgroup = list[Length[hour]];           Do[ hourhighgroup[[dummy]] = {Evaluate[tmetgroup1/.highsol]/.t->                    hour[[dummy]],                                                             Evaluate[tmetgroup2/.highsol/.t->hour[[dummy]]]}, {dummy, 1,               endhour}];           hourhighset = Partition[Flatten[hourhighgroup],2];          				tenhourhighgroup = list[Length[tenhour]];           Do[ tenhourhighgroup[[dummy]] = {Evaluate[tmetgroup1/.highsol]/.t->                    tenhour[[dummy]],                                                             Evaluate[tmetgroup2/.highsol/.t->tenhour[[dummy]]]}, {dummy,               1, endtenhour}];           tenhourhighset = Partition[Flatten[tenhourhighgroup],2];          		highgroup = list[Length[rest]];           Do[ highgroup[[dummy]] = {Evaluate[tmetgroup1/.highsol]/.t->                    rest[[dummy]],                                                             Evaluate[tmetgroup2/.highsol/.t->rest[[dummy]]]}, {dummy, 1,               end}];           highset = Partition[Flatten[highgroup],2];			                    plot = MultipleListPlot[ hourhighset,tenhourhighset,highset,                AxesLabel->label, PlotRange->All,                                         Axes->True,                                                         SymbolShape->{ PlotSymbol[Star, 1.5,Filled->False],                  PlotSymbol[Star, 1.5,Filled->False],                  PlotSymbol[Star, 1.5,Filled->False]},              SymbolStyle->{RGBColor[1,0,0],RGBColor[0,1,0],                   RGBColor[0,0,1] }];           If[ n >1,            Print[n,                           "  Hours\nRed Points: 0-1 Minute\nGreen Points: 1 Minute - 1 \Hour"], Print[n,               "  Hours \n Red Points: 0-1 Minute"]];, (ic1 ===0)&&(            ic2 ===0),           Return [Print[                            "You need to enter at least one set of initial conditions!"]]; ];        plot]; ]; plotphaseplane[n_:100,met1_:ATP,met2_:DPG23,highsol_:sol,filename_:none,      draw_:1,num_:50]:=    Module[{t0,tmp,loop,tenhourhighgroup,highgroup,hourhighgroup,highset,        hourhighset,tenhourhighset,tenhourhighgroup2,highgroup2,        hourhighgroup2,highset2,hourhighset2,tenhourhighset2,label,highsol2,        plot,rxn,increment,tmetgroup1,tmetgroup2,first,hour,tenhour,rest,        power,dummy,dummy1,endhour,endtenhour,sub,end},      If[(Length[met1]>3)||(Length[met2]>3),label={"met1","met2"};,        label={newlabel[met1],newlabel[met2]};];      sub={G6P\[Rule]G6P[t],F6P\[Rule]F6P[t],FDP\[Rule]FDP[t],          DHAP\[Rule]DHAP[t],GAP\[Rule]GAP[t],DPG13\[Rule]DPG13[t],          DPG23\[Rule]DPG23[t],PG3\[Rule]PG3[t],PG2\[Rule]PG2[t],          PEP\[Rule]PEP[t],PYR\[Rule]PYR[t],LAC\[Rule]LAC[t],          NADH\[Rule]NADH[t],GL6P\[Rule]GL6P[t],GO6P\[Rule]GO6P[t],          NADPH\[Rule]NADPH[t],GSH\[Rule]GSH[t],RU5P\[Rule]RU5P[t],          R5P\[Rule]R5P[t],X5P\[Rule]X5P[t],S7P\[Rule]S7P[t],        E4P\[Rule]E4P[t],          ADO\[Rule]ADO[t],AMP\[Rule]AMP[t],ADP\[Rule]ADP[t],        ATP\[Rule]ATP[t],          PRPP\[Rule]PRPP[t],IMP\[Rule]IMP[t],INO\[Rule]INO[t],        HX\[Rule]HX[t],          R1P\[Rule]R1P[t],ADE\[Rule]ADE[t],NAI\[Rule]NAI[t],KI\[Rule]KI[t],          MGATP\[Rule]MGATP[t],MGADP\[Rule]MGADP[t],MGAMP\[Rule]MGAMP[t],          MGDPG23\[Rule]MGDPG23[t],MG\[Rule]MG[t]};      tmetgroup1=met1/.sub;      tmetgroup2=met2/.sub;      If[draw\[Equal]1,        If[n>2,power=Log[10,n];  increment=power/50;             hour=Table[N[10^dummy],{dummy,-16,-1.77,increment}]; (*minutes*)              tenhour=Table[N[10^dummy],{dummy,-1.77,0,increment}]; (*hour*)              rest=Table[N[10^dummy],{dummy,0,power,increment}];            endhour=Length[hour];            endtenhour=Length[tenhour];            end=Length[rest];            (*highsol=solution[rxn,n,ic1,y];*)hourhighgroup=              list[Length[hour]];                     Do[hourhighgroup[[dummy]]={Evaluate[tmetgroup1/.highsol]/.t\[Rule]                      hour[[dummy]],                  Evaluate[                    tmetgroup2/.highsol/.t\[Rule]hour[[dummy]]]},{dummy,1,                endhour}]; hourhighset=Partition[Flatten[hourhighgroup],2];            tenhourhighgroup=list[Length[tenhour]];             Do[tenhourhighgroup[[dummy]]={Evaluate[                      tmetgroup1/.highsol]/.t\[Rule]tenhour[[dummy]],                  Evaluate[                    tmetgroup2/.highsol/.t\[Rule]tenhour[[dummy]]]},{dummy,1,                endtenhour}];             tenhourhighset=Partition[Flatten[tenhourhighgroup],2];            highgroup=list[Length[rest]];             Do[highgroup[[dummy]]={Evaluate[tmetgroup1/.highsol]/.t\[Rule]                      rest[[dummy]],                  Evaluate[                    tmetgroup2/.highsol/.t\[Rule]rest[[dummy]]]},{dummy,1,                end}]; highset=Partition[Flatten[highgroup],2];	            If[draw\[Equal]1,              plot=MultipleListPlot[hourhighset,tenhourhighset,highset,                  AxesLabel\[Rule]label,PlotRange\[Rule]All,Axes\[Rule]True,                  SymbolShape\[Rule]{PlotSymbol[Star,1.5,Filled\[Rule]False],                      PlotSymbol[Star,1.5,Filled\[Rule]False],                      PlotSymbol[Star,1.5,Filled\[Rule]False]},                  SymbolStyle\[Rule]{RGBColor[1,0,0],RGBColor[0,1,0],                      RGBColor[0,0,1]}];               If[n>1,Print[n,                                                                "  Hours\nRed Points: 0 to 1 Minute\nGreen Points: 1 Minute to \\\\\1 Hour"],Print[n,"  Hours \n Red Points: 0 to 1 Minute"]];];,            If[draw\[Equal]1,Print["Time = ",n," hou\.14rs"];];            dummy=0;            loop=0;            t0=1/3600;            While[dummy<n,dummy=N[t0*10^((loop/100)*(Log[10,n]-Log[10,t0]))];              loop++;];            rest=Table[N[0],{dummy,0,loop}];            dummy=0;            loop=1;            t0=1/3600;            While[dummy<n,rest[[loop]]=N[dummy];              dummy=N[t0*10^((loop/100)*(Log[10,n]-Log[10,t0]))];              loop++;];            end=Length[rest];            hourhighgroup=list[Length[rest]];                     Do[hourhighgroup[[dummy]]={Evaluate[tmetgroup1/.highsol]/.t\[Rule]                      rest[[dummy]],                  Evaluate[                    tmetgroup2/.highsol/.t\[Rule]rest[[dummy]]]},{dummy,1,                end}]; hourhighset=Partition[Flatten[hourhighgroup],2];                        If[draw\[Equal]1,              plot=MultipleListPlot[hourhighset,AxesLabel\[Rule]label,                    PlotRange\[Rule]All,Axes\[Rule]True,                    SymbolShape\[Rule]{PlotSymbol[Star,1.5,                          Filled\[Rule]False]},                    SymbolStyle\[Rule]{RGBColor[1,0,0]}];];];];      If[filename=!=none,tmp=OpenWrite[filename];        If[(Length[newlabel[met1]]>1)||(Length[newlabel[met2]]>1),          WriteString[tmp,"time","\t","met1","\t","met2","\n"];,          WriteString[tmp,"time","\t",newlabel[met1],"\t",newlabel[met2],              "\n"];];        dummy=0;        loop=0;        t0=1/3600;        While[dummy<n,(*Print[dummy];*)           WriteString[tmp,N[dummy],"\t",            Evaluate[tmetgroup1/.highsol[[1]]]/.t\[Rule]dummy,"\t",            Evaluate[tmetgroup2/.highsol[[1]]]/.t\[Rule]dummy,"\n"];          dummy=N[t0*10^((loop/num)*(Log[10,n]-Log[10,t0]))];          loop++;];        Close[filename];];      If[draw\[Equal]1,plot];];(* ---------------------------------------------- *)plotpoolplot[n_:1000,met1_:ATP,sol_:sol,filename_:none]:=    Module[{reactionset,tlist,data,max,label,sub,tmp,dummy,loop,t0},      reactionset=REACTIONS;      sub={G6P\[Rule]G6P[t],F6P\[Rule]F6P[t],FDP\[Rule]FDP[t],          DHAP\[Rule]DHAP[t],GAP\[Rule]GAP[t],DPG13\[Rule]DPG13[t],          DPG23\[Rule]DPG23[t],PG3\[Rule]PG3[t],PG2\[Rule]PG2[t],          PEP\[Rule]PEP[t],PYR\[Rule]PYR[t],LAC\[Rule]LAC[t],          NADH\[Rule]NADH[t],GL6P\[Rule]GL6P[t],GO6P\[Rule]GO6P[t],          NADPH\[Rule]NADPH[t],GSH\[Rule]GSH[t],RU5P\[Rule]RU5P[t],          R5P\[Rule]R5P[t],X5P\[Rule]X5P[t],S7P\[Rule]S7P[t],        E4P\[Rule]E4P[t],          ADO\[Rule]ADO[t],AMP\[Rule]AMP[t],ADP\[Rule]ADP[t],        ATP\[Rule]ATP[t],          PRPP\[Rule]PRPP[t],IMP\[Rule]IMP[t],INO\[Rule]INO[t],        HX\[Rule]HX[t],          R1P\[Rule]R1P[t],ADE\[Rule]ADE[t],NAI\[Rule]NAI[t],KI\[Rule]KI[t],          MGATP\[Rule]MGATP[t],MGADP\[Rule]MGADP[t],MGAMP\[Rule]MGAMP[t],          MGDPG23\[Rule]MGDPG23[t],MG\[Rule]MG[t]};      If[(Length[met1]>3),label="met1"; ,label=newlabel[met1];];      (*sol=solution[reactionset,n,initial,metabolites];*)tlist=met1/.sub;      data=Table[Evaluate[(tlist)/.sol],{t,0,n}]; max=Max[data];      Plot[Evaluate[(tlist)/.sol],{t,0,n},Axes\[Rule]True];      If[filename=!=none,tmp=OpenWrite[filename];        If[(Length[newlaber[met1]]>3),          WriteString[tmp,"time","\t","met1","\n"];,          WriteString[tmp,"time","\t",newlabel[met1],"\n"];];        dummy=0;        loop=0;        t0=1/3600;        While[dummy<n,          WriteString[tmp,N[dummy],"\t",            Evaluate[tlist/.sol[[1]]]/.t\[Rule]dummy,"\n"];          dummy=N[t0*10^((loop/100)*(Log[10,n]-Log[10,t0]))];          loop++;];        Close[filename];];];(*********************************************************            Make a pooled metabolite phase plane -- with various loads applied to     a \metabolites    time is the time interval    met and met2 are the metabolites    ic is the list of initial conditions    y is the list of metabolites    Usage:   *********************************************************)loadphaseplane[      time_, met1_, met2_, initials_:ssic]:=     Module[{input, minusmet, plusmet, order, max, min,highsol, highgroup,         highset, middlesol, middlegroup, middleset, lowsol, lowgroup,       lowset,         plot, label, tmetgroup1, tmetgroup2, loop, t0, dummy, timelist,        loop2},      		input =         Input[        "Enter:\n 1 to apply an energy (ATP) load \n 2 to apply an oxidative \\\\\load \n 3 to apply a load to NADH "];      		order =Input["What order reaction would you like to have?"];      		max = Input["What is the maximum value of the rate constant?"];      		min = Input["What is the minimum value of the rate constant?"];      Which[ input === 1, minusmet = 26; plusmet = 25;, input ===2,         minusmet = 17;, input ===3, minusmet = 13;];       If[ ( Length[met1]>3)|| (Length[met2]>3), label = {"met1", "met2"};         Print[        "The size of either met1 or met2 is too large to label the plot."];,      label = {newlabel[met1], newlabel[met2]};];      tmetgroup1= met1/.tsub[metabolites];      tmetgroup2= met2/.tsub[metabolites];      resetload;      		      		(* data set for high load *)      		      f[minusmet] = f[minusmet] - max*metabolites[[minusmet]]^order;      If[plusmet === 25,         f[plusmet] = f[plusmet] + max*metabolites[[minusmet]]^order;        REACTIONS[[plusmet]] = f[plusmet];];										      		REACTIONS[[minusmet]] = f[minusmet];										      				highsol = solution[REACTIONS, time, initials,metabolites];                  dummy=0;      loop=0;      t0=1/3600;      While[dummy<time,dummy=N[t0*10^((loop/100)*(Log[10,time]-Log[10,t0]))];        loop++;];      timelist=Table[N[0],{dummy,0,loop}];      dummy=0;      loop=1;      t0=1/3600;      While[dummy<time,timelist[[loop]]=N[dummy];        dummy=N[t0*10^((loop/100)*(Log[10,time]-Log[10,t0]))];        loop++;];            highgroup=Table[{0,0},{loop2,0,loop}];      loop2=1;      Do[highgroup[[loop2,1]]=          Evaluate[tmetgroup1/.highsol/.t\[Rule]timelist[[loop2]]];         highgroup[[loop2,2]]=          Evaluate[tmetgroup2/.highsol/.t\[Rule]timelist[[loop2]]],{loop2,1,          Length[timelist]}];            highset=Partition[Flatten[highgroup],2];      		resetload;                  		(* data set for medium load *)      		      f[minusmet] = f[minusmet] - (max+min)/2*metabolites[[minusmet]]^order;      If[ plusmet ===25,		        f[plusmet] = f[plusmet] + (max+min)/2*metabolites[[minusmet]]^order;        REACTIONS[[plusmet]] = f[plusmet];];      	 REACTIONS[[minusmet]] = f[minusmet];      				middlesol = solution[REACTIONS, time, initials];		            middlegroup=Table[{0,0},{loop2,0,loop}];      loop2=1;      Do[middlegroup[[loop2,1]]=          Evaluate[tmetgroup1/.middlesol/.t\[Rule]timelist[[loop2]]];         middlegroup[[loop2,2]]=          Evaluate[tmetgroup2/.middlesol/.t\[Rule]timelist[[loop2]]],{loop2,        1,          Length[timelist]}];            middleset=Partition[Flatten[middlegroup],2];      		resetload;            		      		(* data set for low load *)      		      f[minusmet] = f[minusmet] - min*metabolites[[minusmet]]^order;      If[plusmet ===25,		        f[plusmet] = f[plusmet] + min*metabolites[[minusmet]]^order;		        REACTIONS[[plusmet]] = f[plusmet];			];										      		REACTIONS[[minusmet]] = f[minusmet];      lowsol = solution[REACTIONS, time, initials,metabolites];	            lowgroup=Table[{0,0},{loop2,0,loop}];      loop2=1;      Do[lowgroup[[loop2,1]]=          Evaluate[tmetgroup1/.lowsol/.t\[Rule]timelist[[loop2]]];         lowgroup[[loop2,2]]=          Evaluate[tmetgroup2/.lowsol/.t\[Rule]timelist[[loop2]]],{loop2,1,          Length[timelist]}];            lowset=Partition[Flatten[lowgroup],2];      		resetload;                  		plot =         MultipleListPlot[   highset, middleset,lowset,  AxesLabel->label,                                       PlotRange->All, Axes->True,                                                 PlotLegend->{  "High Load","Medium Load", "Low Load"},                                       SymbolShape->{                                                            PlotSymbol[Diamond, 1.5,Filled->False],                                                             PlotSymbol[Star,1.5,Filled->False],              								              PlotSymbol[Triangle, 1.5,Filled->False]},          SymbolStyle->{RGBColor[1,0,0],RGBColor[0,1,0],RGBColor[0,0,1] },          PlotStyle->{RGBColor[1,0,0],RGBColor[0,1,0],RGBColor[0,0,1] },                                      LegendSize->{0.5,0.5}];       Print[time, "  Hours"];  plot];			(*********************************************************            Make a pooled metabolite phase plane -- with various loads applied to     a \metabolites in different colors for 1st hour    time is the time interval    met and met2 are the metabolites    ic is the list of initial conditions    y is the list of metabolites    Usage:   *********************************************************)altloadphaseplane[time_, met1_, met2_,subssic_] :=     Module[{input, minusmet, plusmet, order, max, min,highsol,       hourhighgroup,         highgroup, hourhighset, highset, middlesol, hourmiddlegroup,         middlegroup, hourmiddleset, middleset, lowsol, hourlowgroup,         lowgroup, hourlowset, lowset, plot, label, tmetgroup1, tmetgroup2,          power, increment, hour, rest, endhour, end, dummy, high, middle,         low},      		input =         Input[        "Enter:\n 1 to apply an energy (ATP) load\n 2 to apply an oxidative \\\\\load"];      		order =Input["What order reaction would you like to have?"];      		max = Input["What is the maximum value of the rate constant?"];      		min = Input["What is the minimum value of the rate constant?"];      Which[ input === 1, minusmet = 26; plusmet = 25;, input ===2,         minusmet = 17; plusmet = 16;];       If[ ( Length[met1]>3)|| (Length[met2]>3), label = {"met1", "met2"};         Print[        "The size of either met1 or met2 is too large to label the plot."];,      label = {newlabel[met1], newlabel[met2]};];      tmetgroup1= met1/.tsub[metabolites];      tmetgroup2= met2/.tsub[metabolites];      resetload;				      		      If[time < 2, time = 2;Print["Time = 2 hours"];];            power = Log[10, time];  increment = power/30;      hour = Table[ N[10^dummy], {dummy, -10, 0, increment}];      rest = Table[ N[10^dummy], {dummy, 0, power, increment}];            			endhour =Length[hour];      			end = Length[rest];      		(* data set for high load *)      		      f[minusmet] = f[minusmet] - max*metabolites[[minusmet]]^order;      		f[plusmet] =         f[plusmet] + max*metabolites[[minusmet]]^order;										      		REACTIONS[[minusmet]] = f[minusmet];										      		REACTIONS[[plusmet]] = f[plusmet];      		highsol = solution[REACTIONS, time, subssic];      				hourhighgroup = list[Length[hour]];       Do[ hourhighgroup[[dummy]] = {Evaluate[tmetgroup1/.highsol]/.t->                hour[[dummy]],                                                     Evaluate[tmetgroup2/.highsol/.t->hour[[dummy]]]}, {dummy, 1,           endhour}];       hourhighset = Partition[Flatten[hourhighgroup],2];      		highgroup = list[Length[rest]];      			Do[         highgroup[[dummy]] = {Evaluate[tmetgroup1/.highsol]/.t\[Rule]                rest[[dummy]],                                                     Evaluate[tmetgroup2/.highsol/.t\[Rule]rest[[dummy]]]}, {dummy,         1,           end}];      		highset = Partition[Flatten[highgroup],2];      				resetload;      		      		(* data set for medium load *)      		      f[minusmet] = f[minusmet] - (max+min)/2*metabolites[[minusmet]]^order;      		f[plusmet] = f[plusmet] + (max+min)/2*metabolites[[minusmet]]^order;      	 REACTIONS[[minusmet]] = f[minusmet];      		REACTIONS[[plusmet]] = f[plusmet];      		middlesol = solution[REACTIONS, time, subssic];		      				hourmiddlegroup = list[Length[hour]];       Do[ hourmiddlegroup[[dummy]] = {Evaluate[tmetgroup1/.middlesol]/.t->                hour[[dummy]],                                                     Evaluate[tmetgroup2/.middlesol/.t->hour[[dummy]]]}, {dummy, 1,           endhour}];       		hourmiddleset = Partition[Flatten[hourmiddlegroup],2];      						middlegroup = list[Length[rest]];       Do[ middlegroup[[dummy]] = {Evaluate[tmetgroup1/.middlesol]/.t\[Rule]                rest[[dummy]],                                                     Evaluate[tmetgroup2/.middlesol/.t\[Rule]rest[[dummy]]]}, {dummy,           1, end}];       		middleset = Partition[Flatten[middlegroup],2];      		resetload;      		      		(* data set for low load *)      		      f[minusmet] = f[minusmet] - min*metabolites[[minusmet]]^order;      		f[plusmet] =         f[plusmet] + min*metabolites[[minusmet]]^order;										      		REACTIONS[[minusmet]] = f[minusmet];      		REACTIONS[[plusmet]] = f[plusmet];										      lowsol = solution[REACTIONS, time, subssic];	      							hourlowgroup = list[Length[hour]];       Do[ hourlowgroup[[dummy]] = {Evaluate[tmetgroup1/.lowsol]/.t->                hour[[dummy]],                                                     Evaluate[tmetgroup2/.lowsol/.t->hour[[dummy]]]}, {dummy, 1,           endhour}];       hourlowset = Partition[Flatten[hourlowgroup],2];      					lowgroup = list[Length[rest]];       Do[ lowgroup[[dummy]] = {Evaluate[tmetgroup1/.lowsol]/.t\[Rule]                rest[[dummy]],                                                     Evaluate[tmetgroup2/.lowsol/.t\[Rule]rest[[dummy]]]}, {dummy, 1,           end}];       lowset = Partition[Flatten[lowgroup],2];      		resetload;      		plot =         MultipleListPlot[   hourhighset, highset, hourmiddleset, middleset,           hourlowset, lowset, AxesLabel->label,                                       PlotRange->All, Axes->True,                                                 PlotLegend->{  "High (0-1)","High (1-)", "Mid (0-1)","Mid (1-)",              "Low(0-1)", "Low (1-)"},                    SymbolShape->{              PlotSymbol[Diamond, 1.5,Filled->False],              PlotSymbol[Diamond, 1.5,Filled->False],               PlotSymbol[Star,1.5,Filled->False],              PlotSymbol[Star,1.5,Filled->False],              PlotSymbol[Triangle, 1.5,Filled->False],              PlotSymbol[Triangle, 1.5,Filled->False]},                    SymbolStyle->{              RGBColor[1,0,0],RGBColor[.6,0,0],              RGBColor[0,1,0],RGBColor[0,.6,0],              RGBColor[0,0,1],RGBColor[0,0,.6]},          PlotStyle->{              RGBColor[1,0,0],RGBColor[.6,0,0],              RGBColor[0,1,0],RGBColor[0,.6,0],              RGBColor[0,0,1],RGBColor[0,0,.6]},          LegendSize->{0.75,0.75}];       Print[time, " Hours"];  plot];			(*********************************************************            Solve the Diff Eq's and plot the results with     metabolites (all in one \shot)    x: reactions      ----CHANGES!!!!    n: time interval    ic: initial conditions    y: metabolites    Usage:   *********************************************************)diffeq[time_,        initials_, initials1_:0, initials2_:0, mets_:metabolites] :=    	    Module[ {diff, tmet, sol, i,k, highsol, lowsol, rxn},       rxn = REACTIONS;      			sol = solution[rxn, time, initials, mets];									       plotting[sol, time,   mets] ];(*********************************************************            Solve the Diff Eq's and plot the results with fluxes (all in one shot)    n: time interval    name: name of enzyme with altered activity -- note the quotes    s: percentage of normal enzyme activity    ic: initial conditions    y: metabolites    Usage: fluxdiffeq[50, "PK  ", 0.5, initial, metabolites]  *********************************************************)fluxdiffeq[n_,        ic__:0, points_:100, y__:metabolites] :=       Module[ {diff, tmet, sol,  highsol, lowsol, reactionset, tflux,         group1,   subgroup,max,  j ,q, k, r, z, dummy, plot, increment},       If[n/points <2, increment = n/points, increment = 2];		      diff = list[Length[fluxes]]; subgroup = list[Length[fluxes]];       max = list[Length[fluxes]];      tmet = list[Length[y]];      tmet = tsub[y];      reactionset = REACTIONS;      tflux = fluxes;       Do[ tflux[[j]] = tflux[[j]]/.tmet, {j, 1, Length[tflux]}];      				sol = solution[reactionset, n, ic, y];       				group1 = list[Length[tflux]] ;      		Do[         group1[[k]] =           Partition[            Flatten[               Table[{t, Evaluate[tflux[[k]]/.sol]}, {t, 0, n, increment}]] ,                      2];         subgroup[[k]] =           Table[ Evaluate[tflux[[k]]/.sol], {t, 0, n, increment}], {k, 1,           Length[tflux]}];      		Do[        max[[dummy]] = Max[ subgroup[[dummy]]], {dummy, 1, Length[fluxes]}];       Do[                      MultipleListPlot[  group1[[dummy]],  PlotLabel->fluxnames[[dummy]],           Axes->True,                   SymbolShape->{  PlotSymbol[Triangle, 1.5, Filled->False]},                   LegendSize->{0.5,0.5} ,           PlotRange->{0, 1.1*max[[dummy]]}] , {dummy, 1, Length[fluxes]}] ];(*********************************************************       Temporal Decomposition ----CHANGES!!!!        x is the reaction list with scale factors substituted in    z is the substitution list of steady state concentrations     y is the metabolite list    Usage:   *********************************************************)decomp[font_:7,       cutoff_:0,ic_:default, norm_:yes,filename_:none,y__:metabolites]:=    Module[      {jacobian, mat, a, b, constant,  val, vec, modes,imodes,tempmodal,         modal, ml,c,d,r,s,tc,              tcl , counter, rxn, roots, newrxn, dummy, finalmat, finaltc,         mat2, tc2,rownum,tempmodalcor,tmp},       rxn = REACTIONS;      newrxn = list[Length[rxn]-5];      Do[newrxn[[dummy]] = rxn[[dummy]], {dummy, 1, Length[newrxn]}];      jacobian = Array[                            mat,{Length[newrxn],Length[newrxn]}];																											      Do[         jacobian[[a,b]] = D[newrxn[[a]] ,y[[b]] ] , {a,1,Length[newrxn]}, {b,          1,Length[newrxn]} ];      If[ ic === default,roots = findroots[2000];,         roots = Table[              metabolites[[dummy]]->ic[[dummy]], {dummy, 1,                 Length[metabolites]}];];      		 constant = jacobian/.roots;       {val, vec} = Eigensystem[constant];       modes = Inverse[vec];       imodes = Transpose[modes];      modal = Table[0, {c,1 ,Length[newrxn]}, {d, 1, Length[newrxn]}];      tempmodal = Table[0, {c,1 ,Length[newrxn]}, {d, 1, Length[newrxn]}];      tempmodalcor = Table[0, {c,1 ,Length[newrxn]}, {d, 1, Length[newrxn]}];            rownum=1;      Print["Imaginary Eigenvalue at:"];      While[rownum \[LessEqual] Length[newrxn],        If[(Abs[Im[val[[rownum]]]]>.0001),            Print[rownum,", ",rownum+1];                           Do[tempmodalcor[[rownum,r]]=Re[imodes[[rownum,r]]],{r,1,                Length[newrxn]}];            Do[tempmodalcor[[rownum+1,r]]=Im[imodes[[rownum,r]]],{r,1,                Length[newrxn]}];rownum++;rownum++,                          Do[tempmodalcor[[rownum,r]]=Re[imodes[[rownum,r]]],{r,1,                Length[newrxn]}];            rownum++];];            Which[norm === yes,         Do[tempmodal[[k]]=tempmodalcor[[k]]/Max[Abs[tempmodalcor[[k]]]],{k,1,              Length[newrxn]}];,norm === full,         tempmodal = tempmodalcor/(Max[Abs[tempmodalcor]]);,norm === no,         tempmodal = tempmodalcor;];            	Do[         modal[[r,s]] =           If[Abs[tempmodal[[r,s]] ]< cutoff, 0, tempmodal[[r,s]] ], {r,1,                  Length[newrxn]},{s,1,Length[newrxn]} ];            tc = Array[tcl, {Length[newrxn]}];      Do[ tc[[counter]] = -1/val[[counter]], {counter, 1, Length[newrxn]}];      finalmat = Table[0, {Length[newrxn]+1}, {Length[newrxn]}];      finaltc = Array[0, {(Length[newrxn]+1)}];      		Clear[r]; Clear[s];      		Do[ finalmat[[1,r]] = y[[r]], {r, 1, Length[newrxn]}];      		Clear[r]; Clear[s];      		Do[        finalmat[[r,s]] = Re[N[modal[[r-1,s]], 2]], {r, 2,           Length[newrxn]+1}, {s, 1, Length[newrxn]}];      		Clear[s];      		finaltc[[1]] = "                                 ";      		Do[finaltc[[s]] = N[tc[[s-1]],2], {s, 2, Length[newrxn]+1}];      		Print[StyleForm[MatrixForm[finalmat], FontSize-> font],        StyleForm[MatrixForm[finaltc], FontSize-> font]];            If[filename=!=none,        tmp=OpenWrite[filename];        WriteString[tmp,mets,"\n"];                    Do[WriteString[tmp,FortranForm[modal[[r]]],"  ;  ",              FortranForm[-1/val[[r]]],"\n"],{r,1,Length[mets]}];        Close[filename];        ];            	Return[{-1/val,modal}];];(*********************************************************            arg1: first argument          arg2: second argument              Find the fractional change of two                             numbers (i.e. fluxes, metabolite concentrations)              Usage: delta = delta[G6P, G6Ppkdef]      returns the fractional change  *********************************************************)delta[arg1_,      arg2_]:=Module[{value,result},      Which[arg1\[Equal]0 ,value="nope",arg2\[Equal]0 ,value="nope",        arg1\[NotEqual]0,value=100*(arg2-arg1)/Abs[arg1]];       If[value=!="nope",result=N[value,2],        result=StringForm["Net Change: ``",arg2-arg1]];      result];(*********************************************************        name: name of altered enzyme         value: % of normal enzyme activity                        Usage: compare[PFK , 0.7,                     1000] -- returns a list of the percent change  *********************************************************)compare[  name_,       value_, iterations_:2000]:=       Module[{roots1, roots2, fluxlist, metlist, i,j, metgroup, fluxgroup,               finalgroup, f1, f2},       resetscale;      roots1 = findroots[ iterations];      setscale[name,value];											      roots2 = findroots[  iterations];      metlist  = list[Length[metabolites]];      fluxlist = list[Length[fluxes]];      metgroup = list[Length[metabolites]];      fluxgroup = list[Length[fluxes]];      f1 = list[Length[fluxes]];      f2 = list[Length[fluxes]];      finalgroup  = list[Length[metabolites]+Length[fluxes]];      fluxlist = subreactions[name, value, fluxes,  scale];      Do[        metgroup[[i]] = {metabolites[[i]],                                  metlist[[i]] = delta[roots1[[i,2]],roots2[[i,2]] ]}, {i, 1,                   Length[metabolites]}];      Do[ f1[[j]] = fluxlist[[j]]/.roots1;         f2[[j]] = fluxlist[[j]]/.roots2;        fluxgroup[[j]] ={fluxnames[[j]],             fluxlist[[j]] = delta[f1[[j]], f2[[j]]]}, {                  j, 1, Length[fluxes]}];      metgroup = Append[metgroup, fluxgroup];      finalgroup = Partition[Flatten[metgroup], 2];      		resetscale;      TableForm[finalgroup, TableDepth->2] ];(*********************************************************       Plots the pooled metabolites over a specified time interval    initial: initial conditions        n: time interval            Usage: poolplot[ 1000, G6P+ F6P, ic]   *********************************************************) poolplot[ n_:1000, met1_,  initial__:ic,  y__:metabolites]:=       Module[ { reactionset, sol,  tlist,data, max, label},      reactionset = REACTIONS;      		If[ ( Length[met1]>3), label = "met1";         Print["The size of either met1 is too large to label the plot."];,        label = newlabel[met1];];      sol = solution[reactionset, n, initial, metabolites];       tlist = met1/.tsub[metabolites];      data = Table[Evaluate[(tlist)/.sol], {t, 0, n}]; max = Max[data];      	Plot[ Evaluate[(tlist)/.sol] ,{t,0,n},  Axes->True ] ];(*********************************************************            Accessory function for LOG10 plots    Usage:   *********************************************************)						logscale[ time_, points_:150] :=     Module[{power, increment,dummy}, power = Log[10, time];       increment = power/points;       Table[ N[10^dummy], {dummy, -10, power, increment}]];(*********************************************************         Plots the pooled metabolites over a specified time interval -      on a LOG10 scale      initial: initial conditions          n: time interval              met1 through met5: metabolites, to leave one out,     either enter 0 or leave it blank		    Usage: poolplot[ 1000, G6P+ F6P, ic]   *********************************************************) logpoolplot[ time_:100, met1_,  initial__:ic,   extra_:0]:=       Module[ { reactionset, sol,  tlist,logtlist, metlist, dummy, finalist,         data, label, power, increment, max},      reactionset = REACTIONS;      If[ ( Length[met1]>3), label = "met1";         Print["The size of either met1 is too large to label the plot."];,        label = newlabel[met1];];      sol = solution[reactionset, time, initial, metabolites];       If[time < 2,time = 2;Print["Time = 2 hours"];];      		 power = Log[10, time]; increment = power/150;       tlist=Table[ N[10^dummy], {dummy, -10, power, increment}];      		logtlist = Table[ dummy, {dummy, -10, power, increment}];      metlist = met1/.tsub[metabolites];      finalist = list[Length[tlist]];      		Do[        finalist[[dummy]] = {logtlist[[dummy]],            Evaluate[(metlist)/.sol/.t->tlist[[dummy]] ]},{dummy, 1,           Length[tlist]}];      		data = Partition[Flatten[ finalist], 2]; 	      	max=	Max[ Table[data[[dummy, 2]], {dummy, 1, Length[data]}]];      							      ListPlot[data, AxesLabel->{"Log[Time]", label},        PlotRange->{0, 1.1max} ] ];							(*********************************************************       Plots the energy charge of the cell over a specified time interval    initial: initial conditions        n: time interval            Usage:  *********************************************************)							energycharge[n_,  ic__,  y__:metabolites, o__:scale]:= Module[{rxn, sol},      rxn = REACTIONS;      sol = solution[REACTIONS, n, ic, y];				      energygroup = (3*ATP + 2*ADP+AMP)/(ATP+ADP+AMP+ADO)/3;      tgroup = energygroup/.tsub[y];      Plot[ (Evaluate[ tgroup/.sol] ), {t, 0, n},       PlotLabel-> "Energy Charge",        Axes->True] ];	(*********************************************************       Plots the energy charge of the cell over a specified time     interval -- \LOG10 scale    initial: initial conditions        n: time interval            Usage:  *********************************************************)							logenergycharge[n_,  ic__,  y__:metabolites, o__:scale]:=     Module[{rxn, sol, power, increment, dummy, logtlist, finalist, tlist,         data},      rxn = REACTIONS;      sol = solution[REACTIONS, n, ic, y];				      energygroup = (3*ATP + 2*ADP+AMP)/(ATP+ADP+AMP+ADO)/3;      		tgroup = energygroup/.tsub[y];      If[n < 2, n = 2;Print["Time = 2 hours"];];      				 power = Log[10, n]; increment = power/150;       tlist=Table[ N[10^dummy], {dummy, -10, power, increment}];      		logtlist = Table[ dummy, {dummy, -10, power, increment}];      finalist = list[Length[tlist]];      		Do[        finalist[[dummy]] = {logtlist[[dummy]],            Evaluate[tgroup/.sol/.t->tlist[[dummy]] ]},{dummy, 1,           Length[tlist]}];      		data = Partition[Flatten[ finalist], 2]; 	      ListPlot[ data ,AxesLabel->{"Log[Time]", "Energy Charge"},        Axes->True] ];											(********************************************************    		Plot the percent normal activity versus a specified flux -- steady \state values  ********************************************************)deficiency[flux_,       enzyme_:HK, low_:0.5, high_:1.5] :=     Module[ {maxit, points,  increment, values, label, roots,  counter,         name1, name2, dummy},       	resetscale;	maxit = 5000; points = 15; counter = 1;      		name1 = pickfluxname[flux]; name2 = pickfluxname[enzyme];      		increment = (high - low)/points;      		label = StringForm[" `` vs % `` Activity",name1, name2 ];      		Do[ setscale[enzyme, dummy]; roots = findroots[maxit];        			temp =flux/.roots;        			values[[counter]] = {dummy,temp};        			counter++	, {dummy, low, high, increment}]; resetscale;      		ListPlot[values, PlotJoined->True, PlotLabel->label,         PlotJoined->True] ];(*********************************************************         Fixes IC's - just correct MG complexing      set: substitution list of metabolites (e.g. roots)          Usage:  *********************************************************)										rootsfixmg[set__] :=     Module[{newset, adenoset, dummy, root1, root2, root3, root4, root5, mg,         leftover, other, fullroot1,  compare, count, eq},      		newset = list[Length[set]];      newset = metabolites/.set;      adenoset = {set[[7]], set[[24]], set[[25]], set[[26]]};      eq = (	            MG +(AMP MG)/(MG+mgampk) + (ADP MG)/(MG+mgadpk)+(ATP MG)/(MG+                      mgatpk) +(DPG23 MG)/(MG+mgdpgk)  == MGT)/.adenoset;      		root1 = FindRoot[eq, {MG,0.43}];      		fullroot1 = Flatten[root1];      		compare = list[Length[fullroot1]];      		Do[        compare[[count]] = fullroot1[[count, 2]], {count, 1,           Length[fullroot1]}];      		mg  = fullroot1[[1,1]]->Max[ compare];      		newset[[39]] = MG/.mg;      		newset[[35]] = (ATP MG)/(MG+mgatpk)/. adenoset/.mg;      		newset[[36]] = (ADP MG)/(MG+mgadpk)/. adenoset/.mg;      		newset[[37]] = (AMP MG)/(MG+mgampk)/. adenoset/.mg;      		newset[[38]] = (DPG23 MG)/(MG+mgdpgk)/. adenoset/.mg;       newset];					(*********************************************************         Fixes IC's - just correct MG complexing      set: a list of initial conditions (NOT substitution rules)          Usage:  *********************************************************)										fixmg[set__] :=     Module[{newset, adenoset, dummy, root1, root2, root3, root4, root5, mg,         leftover, other, fullroot1,  compare, count, eq},      		newset = set;      adenoset = {DPG23->set[[7]],AMP-> set[[24]], ADP->set[[25]],          ATP-> set[[26]]};      eq = (	            MG +(AMP MG)/(MG+mgampk) + (ADP MG)/(MG+mgadpk)+(ATP MG)/(MG+                      mgatpk) +(DPG23 MG)/(MG+mgdpgk)  == MGT)/.adenoset;      		      		root1 = FindRoot[eq, {MG,0.43}];      		fullroot1 = Flatten[root1];      		compare = list[Length[fullroot1]];      		Do[        compare[[count]] = fullroot1[[count, 2]], {count, 1,           Length[fullroot1]}];      		mg  = fullroot1[[1,1]]->Max[ compare];      		newset[[39]] = MG/.mg;      		newset[[35]] = (ATP MG)/(MG+mgatpk)/. adenoset/.mg;      		newset[[36]] = (ADP MG)/(MG+mgadpk)/. adenoset/.mg;      		newset[[37]] = (AMP MG)/(MG+mgampk)/. adenoset/.mg;      		newset[[38]] = (DPG23 MG)/(MG+mgdpgk)/. adenoset/.mg;       newset];					(*********************************************************       Returns a set of steady state initial conditions based on REACTIONS    Usage:  *********************************************************)				SSIC := Module[{roots, icset, dummy},roots = findroots[];       icset =  list[Length[roots]];       Do[icset[[dummy]] = roots[[dummy,2]], {dummy, 1, Length[roots]}];      		icset ];(*********************************************************       	OPTIONS for NDSolve   *********************************************************)				BUMP :=1;(******************************)If[$VersionNumber < 4, WORKINGPRECISION :=16,    WORKINGPRECISION :=19];ACCURACYGOAL:=13; MAXSTEPS:=5000; pickmet[metname_] :=          Which[ metname===G6P, 1, metname ===F6P, 2, metname ===FDP,3,          metname ===DHAP,4,metname ===GAP,5,metname ===DPG13,6,      metname ===DPG23,7,          metname ===PG3,8,metname ===PG2,9,metname ===PEP,10,metname ===PYR,      11,          metname ===LAC,12,metname ===NADH,13,metname ===GL6P,14,      metname ===GO6P,          15,metname ===NADPH,16,metname ===GSH,17,metname ===RU5P,18,      metname ===R5P,          19,metname ===X5P,20,metname ===S7P,21,metname ===E4P,22,      metname ===ADO,23,          metname ===AMP,24,metname ===ADP,25,metname ===ATP,26,      metname ===PRPP,27,          metname ===IMP,28,metname ===INO,29,metname ===HX,30,    metname ===R1P,      31,          metname ===ADE,32, metname === NAI, 33, metname === KI, 34,           metname ===MGATP,35,metname ===MGADP,36,metname ===MGAMP,37,          metname ===MGDPG23,38,metname ===MG,39,metname ===0, 0];pickflux[flux_] :=          Which[ flux===HK, 1, flux ===PGI, 2, flux ===PFK,3,flux ===ALD,4,          flux ===TPI,5,flux ===GAPDH,6,flux ===PGK,7,flux ===DPGM,8,      flux ===DPGase,          9,flux ===PGM,10,flux ===EN,11,flux ===PK,12,flux ===PEX,13,      flux ===LDH,          14,flux ===LEX,15,flux ===AMPase,16,flux ===ADA,17,flux ===AK,18,          flux ===ADK,19,flux ===AMPDA,20,flux ===ATPase,21,flux ===ADPRT,22,          flux ===G6PDH,23,flux ===PGLase,24,flux ===GL6PDH,25,flux ===GSSGR,      26,          flux ===GSHR,27,flux ===RU5PI,28,flux ===XU5PE,29,flux ===TKI,30,          flux ===TKII,31,flux ===TALD,32, flux ===IMPase, 33,       flux ===PNPase, 34,           flux ===PRM, 35, flux ===PRPPSYN, 36, flux ===HGPRT, 37,       flux ===HXEX,           38, flux ===ADEEX, 39, flux === ADOEX, 40, flux === INOEX, 41,      flux === NALEAK, 42, flux === KLEAK, 43, flux === PUMP, 44];pickfluxname[fluxname_] :=          Which[fluxname === HK, "HK Flux",fluxname === PFK, "PFK Flux",          fluxname === PGK , "PGK Flux",fluxname === DPGM , "DPGM Flux",          fluxname === DPGase, "DPGase Flux",fluxname === PGM, "PGM Flux",          fluxname === PK , "PK Flux",fluxname === PEX , "PEX Flux",          fluxname === LAC, "LAC Flux",fluxname === AMPase, "AMPase Flux",          fluxname ===ADA , "ADA Flux",fluxname === AK , "AK Flux",          fluxname === ADK, "ADK Flux",fluxname ===AMPDA , "AMPDA Flux",          fluxname ===ATPase , "ATPase Flux",fluxname === ADPRT,       "ADPRT Flux",          fluxname === AEX, "AEX Flux",fluxname === G6PDH, "G6PDH Flux",          fluxname === GL6PDH, "GL6PDH Flux",fluxname ===PGLase ,       "PGLase Flux",          fluxname === GSSGR, "GSSGR Flux",fluxname ===R5PI , "R5PI Flux",          fluxname ===XU5PI , "XU5PI Flux",fluxname === TKI, "TKI Flux",          fluxname ===TKII , "TKII Flux",fluxname === TALD, "TALD Flux",        fluxname ===IMPase, "IMPase Flux", fluxname ===PNPase, "PNPase Flux",           fluxname ===PRM, "PRM Flux", fluxname ===PRPPSYN, "PRPPSYN Flux",       fluxname ===HGPRT, "HGPRT Flux", fluxname ===HXEX,           "HXEX Flux", fluxname ===ADEEX, "ADEEX Flux", fluxname === INOEX,       "INOEX FLUX",fluxname === NALEAK, "NALEAK Flux", fluxname === KLEAK,       "KLEAK Flux", fluxname === PUMP, "PUMP Flux", 1===1, fluxname ];pickscale[in_] :=          Which[in === HK,scalehk,in===PGI, scalepgi,in=== PFK , scalepfk,      in===ALD ,           scaleald,in===TPI, scaletpi,in===GAPDH, scalegapdh,in===PGK,       scalepgk,          in===DPGM, scaledpgm,in===DPGase, scaledpgase,in===PGM, scalepgm,      in===EN,           scaleen,in===PK, scalepk,in===PEX, scalepex,in===LDH, scaleldh,      in===LEX,           scalelex,in===AMPase, scaleampda,in===ADA, scaleada,in===AK,       scaleak,           in===ADK,scaleadk,in===AMPDA, scaleampda,in===ATPase, scaleatpase,          in===ADPRT, scaleadprt,in===G6PDH, scaleg6pd,in===PGLase,       scalepglase,          in===GL6PDH, scalegl6pd,in===GSSGR, GSSGR,in===GSHR, scalegshr,          in===RU5PI, scaleru5pi,in===XU5PE, scalexu5pe,in===TKI, scaletki,          in===TKII, scaletkii,in===TALD, scaletald,in===IMPase, scaleimpase,          in===PNPase, scalepnpase,in===PRM, scaleprm,in===PRPPSYN,       scaleprppsyn,          in===HGPRT, scalehgprt,in===HXEX, scalehxex,in===ADEEX,     scaleadeex,       in===ADOEX, scaleadoex,          in === INOEX, scaleinoex,in === NALEAK, scalenaleak, in=== KLEAK,      scalekleak, in === PUMP,  scalepump];(*********************************************************       Adjusts the value of a particular enzyme    Usage:  *********************************************************)			setscale[enzyme_, activity_] := Module[{},        Which[enzyme === HK,scalehk := activity,enzyme===PGI,         scalepgi:= activity,enzyme=== PFK , scalepfk:= activity,        enzyme===ALD ,             scaleald:= activity,enzyme===TPI, scaletpi:= activity,        enzyme===GAPDH, scalegapdh:= activity,enzyme===PGK,         scalepgk:= activity,            enzyme===DPGM, scaledpgm:= activity,enzyme===DPGase,         scaledpgase:= activity,enzyme===PGM, scalepgm:= activity,        enzyme===EN,             scaleen:= activity,enzyme===PK, scalepk:= activity,enzyme===PEX,         scalepex:= activity,enzyme===LDH, scaleldh:= activity,enzyme===LEX,             scalelex:= activity,enzyme===AMPase, scaleampda:= activity,        enzyme===ADA, scaleada:= activity,enzyme===AK, scaleak:= activity,             enzyme===ADK,scaleadk:= activity,enzyme===AMPDA,         scaleampda:= activity,enzyme===ATPase, scaleatpase:= activity,            enzyme===ADPRT, scaleadprt:= activity,enzyme===G6PDH,         scaleg6pd:= activity,enzyme===PGLase, scalepglase:= activity,            enzyme===GL6PDH, scalegl6pd:= activity,enzyme===GSSGR,         scalegssgr:= activity,enzyme===GSHR, scalegshr:= activity,            enzyme===RU5PI, scaleru5pi:= activity,enzyme===XU5PE, scalexu5pe,        enzyme===TKI, scaletki:= activity,            enzyme===TKII, scaletkii:= activity,enzyme===TALD,         scaletald:= activity,enzyme===IMPase, scaleimpase:= activity,            enzyme===PNPase, scalepnpase:= activity,enzyme===PRM,         scaleprm:= activity,enzyme===PRPPSYN, scaleprppsyn:= activity,            enzyme===HGPRT, scalehgprt:= activity,enzyme===HXEX,         scalehxex:= activity,enzyme===ADEEX, scaleadeex, enzyme===ADOEX,         scaleadoex:= activity,enzyme === INOEX, scaleinoex :=activity,            enzyme === NALEAK, scalenaleak:= activity, enzyme=== KLEAK,        scalekleak:= activity, enzyme === PUMP,  scalepump:= activity, 1===1,        Return[Print["No Match! Check the abbreviation being used."]]; ];       REACTIONS ]; (* picking the label names -- for phase planes *)pickname[arg_] :=      Which[ arg ===HK , "HK Flux",arg === -HK, -"HK Flux",arg === PGI ,      "PGI Flux",arg ===-PGI, -"PGI Flux", arg ===PFK,"PFK Flux",       arg ===-PFK, -"PFK Flux", arg ===ALD, "ALD Flux",      arg === -ALD, -"ALD Flux",arg === TPI,"TPI Flux",      arg === -TPI ,-"TPI Flux",           arg ===GAPDH ,"GAPDH Flux",arg === -GAPDH, -"GAPDH Flux",      arg ===PGK,"PGK Flux",arg === -PGK, -"PGK Flux", arg ===DPGM ,      "DPGM Flux",arg === -DPGM, -"DPGM Flux",           arg ===DPGase,"DPGase Flux",arg === -DPGase, -"DPGase Flux",       arg ===PGM,"PGM Flux",arg === -PGM, -"PGM Flux",arg === EN, "EN Flux",      arg ===-EN, -"EN Flux",           arg ===PK, "PK Flux",arg === -PK, -"PK Flux", arg ===PEX ,      "PEX Flux",arg === -PEX, -"PEX Flux",           arg ===LEX, "LAC Flux",arg ===-LEX, -"LAC Flux",arg ===LDH ,      "LDH Flux", arg ===-LDH, -"LDH Flux", arg ===AMPase,"AMPase Flux",      arg === -AMPase, -"AMPase Flux",          arg ===ADA, "ADA Flux",arg === -ADA, -"ADA Flux",arg ===AK ,      "AK Flux",arg ===-AK, -"AK Flux",          arg ===ADK,"ADK Flux",arg === -ADK, -"ADK Flux",arg ===AMPDA,       "AMPDA Flux",arg ===-AMPDA, -"AMPDA Flux",          arg ===ATPase,  "ATPase Flux",arg === -ATPase, -"ATPase Flux",       arg ===ADPRT,"ADPRT Flux", arg ===-ADPRT, -"ADPRT Flux",       arg ===G6PDH,"G6PDH Flux", arg ===-G6PDH, -"G6PDH Flux",     arg ===GL6PDH,      "GL6PDH Flux", arg ===-GL6PDH, -"GL6PDH Flux",arg ===PGLase,       "PGLase Flux", arg ===-PGLase, -"PGLase Flux",         arg ===GSSGR ,"GSSGR Flux",  arg ===-GSSGR, -"GSSGR Flux",       arg ===GSHR , "GSHR Flux",arg === -GSHR, -"GSHR Flux",arg ===R5UPI ,       "RU5PI Flux",arg === -RU5PI, -"RU5PI Flux",         arg ===XU5PE , "XU5PI Flux", arg ===-XU5PE , -"XU5PI Flux",       arg ===TKI, "TKI Flux", arg ===-TKI, -"TKI Flux",      arg ===TKII , "TKII Flux",arg ===-TKII, -"TKII Flux",arg ===TALD,       "TALD Flux",arg === -TALD, -"TALD Flux",arg ===IMPase, "IMPase Flux",      arg === -IMPase, -"IMPase Flux",arg ===PNPase, "PNPase Flux",      arg === -PNPase, -"PNPase Flux",           arg ===PRM, "PRM Flux",arg === -PRM, -"PRM Flux",arg ===PRPPSYN,       "PRPPSYN Flux",arg === -PRPPSYN, -"PRPPSYN Flux", arg ===HGPRT,       "HGPRT Flux", arg ===-HGPRT, -"HGPRT Flux",arg ===HXEX,           "HXEX Flux", arg ===-HXEX,-"HXEX Flux",arg ===ADEEX, "ADEEX Flux",      arg === -ADEEX, -"ADEEX Flux",  arg ===ADOEX , "ADOEX Flux",       arg === -ADOEX, -"ADOEX Flux",arg ===INOEX, "INOEX FLUX",       arg ===-INOEX, -"INOEX FLUX", arg ===NALEAK, "NALEAK Flux",       arg ===-NALEAK, -"NALEAK Flux",  arg ===KLEAK, "KLEAK Flux",       arg ===-KLEAK, -"KLEAK Flux",  arg ===PUMP, "PUMP Flux",       arg ===-PUMP, -"PUMP Flux", arg===arg, arg ];newlabel[arg_] :=     Module[{met, zzzz, longlist}, met = arg - zzzz;      longlist = Map[pickname[#]&, met];Drop[longlist,-1]];manload[input_:1,power_:0,constant_:0.3]:=    Module[{minusmet,plusmet},      Which[input===1,minusmet=26; plusmet=25;,input===2,minusmet=17;,        input===3,minusmet=13;];       f[minusmet]=f[minusmet]-constant*metabolites[[minusmet]]^power;      REACTIONS[[minusmet]]=f[minusmet];      If[plusmet===25,        f[plusmet]=f[plusmet]+constant*metabolites[[minusmet]]^power;         REACTIONS[[plusmet]]=f[plusmet];]; REACTIONS;];load:=Module[{input,minusmet,plusmet,power,constant},      input=Input[                  "Enter:\n 1 to apply an energy (ATP) load \n 2 to apply an oxidative \\\\\load \n 3 to apply a load to NADH "];      power=        Input[        "What 'order' reaction do you want? Zero order, first order, second \\\\\order, etc (enter:  0, 1, 2)"];      constant=Input["What is the value of the rate constant?"];      Which[input===1,minusmet=26; plusmet=25;,input===2,minusmet=17;,        input===3,minusmet=13;];       f[minusmet]=f[minusmet]-constant*metabolites[[minusmet]]^power;      REACTIONS[[minusmet]]=f[minusmet];      If[plusmet===25,        f[plusmet]=f[plusmet]+constant*metabolites[[minusmet]]^power;         REACTIONS[[plusmet]]=f[plusmet];]; REACTIONS;];resetload := Module[{} ,      f[1] := HK - PGI - G6PDH;(* G6P *)            f[2] := PGI - PFK +TALD +TKII; (* F6P *)            f[3] := PFK - ALD; (* FDP *)      f[4] := ALD - TPI; (* DHAP *)            f[5] := ALD + TPI - GAPDH + TKI + TKII - TALD; (* GAP *)            f[6] := GAPDH - PGK - DPGM; (* DPG13 *)            f[7] := DPGM - DPGase; (* DPG23 *)            f[8] := PGK - PGM + DPGase; (* PG3 *)      f[9] := PGM  - EN; (* PG2 *)            f[10]:= EN - PK; (* PEP *)      f[11] := PK - PEX - LDH; (* PYR *)            f[12] := LDH - LEX; (* LAC *)            f[13] := GAPDH - LDH; (* NADH *)            f[14] := G6PDH - PGLase; (* GL6P *)            f[15] := PGLase - GL6PDH; (* GO6P *)             f[16] := -GSSGR + G6PDH + GL6PDH; (* NADPH *)       f[17] := 2*GSSGR - GSHR; (* GSH *)            f[18] := GL6PDH - RU5PI - XU5PE; (* RU5P *)            f[19] := RU5PI - TKI +PRM - PRPPSYN; (* R5P *)            f[20] :=  XU5PE - TKI - TKII; (* X5P *)            f[21] := TKI - TALD; (* S7P *)      f[22] := TALD - TKII; (* E4P *)            f[23] := AMPase - ADA - AK    - ADOEX; (* ADO *)            f[24] := ADPRT +AK +ADK - AMPase - AMPDA +PRPPSYN; (* AMP *)            f[25] := HK +PFK - PGK - PK +AK - 2*ADK +ATPase  + PUMP;(* ADP *)            f[26] := PK +PGK - HK - PFK +ADK - AK -PRPPSYN - ATPase  - PUMP; (*         ATP *)      f[27] := PRPPSYN - ADPRT - HGPRT; (* PRPP *)            f[28] := AMPDA - IMPase +HGPRT; (* IMP *)            f[29] := IMPase +ADA - PNPase   -INOEX; (* INO *)       f[30] := PNPase - HXEX - HGPRT; (* HX *)            f[31] := PNPase - PRM; (* R1P *)            f[32] := -ADPRT - ADEEX; (* ADE *)        f[33]:= NALEAK - 3*PUMP; (* NAI *)            f[34] := KLEAK + 2*PUMP; (* KI *)          f[35] :=-MGATP+(ATP MG)/(MG+mgatpk); (* MGATP *)            f[36] :=-MGADP+(ADP MG)/(MG+mgadpk); (* MGADP *)            f[37] := -MGAMP+(AMP MG)/(MG+mgampk); (* MGAMP *)            f[38] := -MGDPG23+(DPG23 MG)/(MG+mgdpgk); (* MGDPG23 *)        f[39] :=        MG + (AMP MG)/(MG+mgampk) + (ADP MG)/(MG+mgadpk) + (ATP MG)/(MG+                mgatpk) + (DPG23 MG)/(MG+mgdpgk) - MGT; (* MG *)      	      Clear[REACTIONS]; DECLARE;];resetscale:=     Module[ {rxns},scalehk :=1;scalepgi:=1;scalepfk:=1;scaleald:=1;      scaletpi:=1;scalegapdh:=1;scalepgk:=1;scaledpgm:=1;scaledpgase:=1;      scalepgm:=1;scaleen:=1;scalepk:=1;scalepex:=1;scaleldh:=1;scalelex:=1;      scaleampase:=1;scaleada:=1;scaleak:=1;scaleadk:=1;scaleampda:=1;      scaleatpase:=1;scaleadprt:=1;scaleg6pd:=1;scalepglase:=1;scalegl6pd:=1;      scalegssgr:=1;scalegshr:=1;scaleru5pi:=1;scalexu5pe:=1;scaletki:=1;      scaletkii:=1;scaletald:=1;scaleimpase:=1;scalepnpase:=1;scaleprm:=1;      scaleprppsyn:=1;scalehgprt:=1;scalehxex:=1;scaleadeex:=1;    scaleadoex:=1;       scaleinoex = 1; scalenaleak:=1;scalekleak:=1;scalepump:=1;       Clear[REACTIONS]; DECLARE;];							changemgt :=     Module[{},       MGT = Input[                    "Enter the desired total magnesium concentration in mM (default is \2.7). Only enter the numerical value, do not include units."];];changepi :=     Module[{},       PI = Input[                    "Enter the desired inorganic phosphate concentration in mM (default \\\\\is 1.2). Only enter the numerical value, do not include units."];];changenae :=     Module[{},       NAE = Input[                    "Enter the desired external sodium concentration in mM (default is \140). Only enter the numerical value, do not include units."];];changeglc :=     Module[{},       GLC =  Input[                    "Enter the desired glucose concentration in mM (default is 5). Only \\\\\enter the numerical value, do not include units."];];changert :=     Module[{},       RT =  Input[            "Enter the desired Donnan Ratio in mM (default is 0.6)."];];resetmgt := MGT = 2.7; resetpi := PI = 1.2;  resetnae :=   NAE = 140;  resetglc := GLC = 5; resetrt := RT = 0.6;resetall :=     Module[{}, resetmgt; resetpi; resetnae; resetglc; resetrt; resetload;       resetscale;       Print[      "All loads and enzyme deficiencies have been removed, and all \parameters have been reset to default values."]];			Off[Set::noval];showtime := <<Utilities`ShowTime`;(* Added 8/14/00 *)plotset2[n_,initial_,group_,groupname_:Null,label_:Null,answer1_:Null]:=    Module[{answer,dummy,dummy1,dummy2,element,var,all,tmet,final,power,        increment1,increment2,increment3,minute,hour,rest,fullsettemp,        fullset},      If[answer1===Null,answer=solution[REACTIONS,n,initial],answer=answer1];      tmet=tsub[metabolites];      power=Log[10,n];       Which[n\[LessEqual]N[1/60],increment1=Abs[-16-Log[10,1/60]]/50;        minute=Table[N[10^dummy],{dummy,-16,Log[10,n],increment1}];        hour=Null; rest=Null;,n\[LessEqual]1,        increment1=Abs[-16-Log[10,1/60]]/50;        increment2=Abs[Log[10,1/60]-n]/50;        minute=Table[N[10^dummy],{dummy,-16,Log[10,1/60],increment1}];         hour=Table[N[10^dummy],{dummy,Log[10,1/60],n,increment2}];       rest=Null;,        n>1,increment1=Abs[-16-Log[10,1/60]]/50;        increment2=Abs[Log[10,1/60]-0]/50;        increment3=Abs[power]/50;		        minute=Table[N[10^dummy],{dummy,-16,Log[10,1/60],increment1}];         hour=Table[N[10^dummy],{dummy,Log[10,1/60],0,increment2}];         rest=Table[N[10^dummy],{dummy,0,power,increment3}];];      If[hour=!=Null,fullsettemp=Flatten[Append[minute,hour]];,        fullsettemp=Flatten[minute];];      If[rest=!=Null,fullset=Flatten[Append[fullsettemp,rest]];,        fullset=fullsettemp;];	      Table[var[dummy]=          Flatten[Table[                          group[[dummy]]/.tmet/.t\[Rule]fullset[[dummy1]]/.answer,{dummy1,                1,Length[fullset]}]],{dummy,1,Length[group]}];      all=list[Length[group]+1];      Do[all[[dummy1+1]]=          Table[ListPlot[foldlist[var[dummy1],var[dummy2]],              DisplayFunction\[Rule]Identity,Axes\[Rule]False,              PlotJoined\[Rule]True,PlotRange\[Rule]All,              AspectRatio\[Rule]1],{dummy2,1,Length[group]}],{dummy1,1,          Length[group]}];      If[groupname===Null,        all[[1]]=          Table[If[dummy\[NotEqual]0,              Graphics[Text[group[[dummy]],{0,0},{0,0},{0,-0.75}]],              Graphics[Text["group",{0,0}]]],{dummy,0,Length[group]}];        Do[          all[[dummy]]=            Prepend[all[[dummy]],              Graphics[Text[group[[dummy-1]],{0,0}]]],{dummy,2,            Length[group]+1}];,        all[[1]]=          Table[If[dummy\[NotEqual]0,              Graphics[Text[groupname[[dummy]],{0,0},{0,0},{0,-0.75}]],              Graphics[Text["group",{0,0}]]],{dummy,0,Length[groupname]}];        Do[          all[[dummy]]=            Prepend[all[[dummy]],              Graphics[Text[groupname[[dummy-1]],{0,0}]]],{dummy,2,            Length[groupname]+1}];];      If[label=!=Null,all[[1,1]]=Graphics[Text[label,{0,0}]],        Graphics[Text["",{0,0}]]];      Show[        GraphicsArray[Table[all[[dummy]],{dummy,1,Length[all]}],          ImageSize\[Rule]{450,450},AspectRatio\[Rule]1]]];foldlist[list1_,list2_]:=    Module[{l1,l2,dummy},l1=Length[list1]; l2=Length[list2];       If[l1\[NotEqual]l2,Return["The lists must be of equal length"]];       result=Partition[          Flatten[Table[{list1[[dummy]],list2[[dummy]]},{dummy,1,l1}]],2]];plotmodeset[n_,initial_,cutoff_]:=    Module[{answer,val,vec,index1,index2,dummy,dummy1,dummy2,group,element,        var,all,tmet,numbers,power,increment1,increment2,increment3,minute,        hour,rest,fullsettemp,fullset},answer=solution[REACTIONS,n,initial];      {val,vec}=decomp[4,cutoff];      numbers=Table[Graphics[Text[dummy,{0,0}]],{dummy,0,Length[mets]}];      tmet=tsub[mets];				power=Log[10,n];       Which[n\[LessEqual]N[1/60],increment1=Abs[-16-Log[10,1/60]]/50;        minute=Table[N[10^dummy],{dummy,-16,Log[10,n],increment1}];        hour=Null; rest=Null;,n\[LessEqual]1,        increment1=Abs[-16-Log[10,1/60]]/50;        increment2=Abs[Log[10,1/60]-n]/50;        minute=Table[N[10^dummy],{dummy,-16,Log[10,1/60],increment1}];         hour=Table[N[10^dummy],{dummy,Log[10,1/60],n,increment2}];       rest=Null;,        n>1,increment1=Abs[-16-Log[10,1/60]]/50;        increment2=Abs[Log[10,1/60]-0]/50;        increment3=Abs[power]/50;		        minute=Table[N[10^dummy],{dummy,-16,Log[10,1/60],increment1}];         hour=Table[N[10^dummy],{dummy,Log[10,1/60],0,increment2}];         rest=Table[N[10^dummy],{dummy,0,power,increment3}];];      If[hour=!=Null,fullsettemp=Flatten[Append[minute,hour]];,        fullsettemp=Flatten[minute];];      If[rest=!=Null,fullset=Flatten[Append[fullsettemp,rest]];,        fullset=fullsettemp;];	      Table[var[dummy]=          Flatten[Table[(Re[vec[[dummy]]].mets)/.tmet/.t\[Rule]                    fullset[[dummy1]]/.answer,{dummy1,1,                Length[fullset]}]],{dummy,1,Length[mets]}];      all=list[Length[mets]+1];      Do[all[[dummy1+1]]=          Table[ListPlot[foldlist[var[dummy1],var[dummy2]],              DisplayFunction\[Rule]Identity,Axes\[Rule]False,              PlotJoined\[Rule]True,PlotRange\[Rule]All,              AspectRatio\[Rule]1],{dummy2,1,Length[mets]}],{dummy1,1,          Length[mets]}];      all[[1]]=Table[Graphics[Text[dummy,{0,0}]],{dummy,0,Length[mets]}];      Do[all[[dummy]]=          Prepend[all[[dummy]],Graphics[Text[dummy-1,{0,0}]]],{dummy,2,          Length[mets]+1}]; all[[1,1]]=Graphics[Text["Mode",{0,0}]];      Show[GraphicsArray[Table[all[[dummy]],{dummy,1,Length[all]}]],        ImageSize\[Rule]{450,450},AspectRatio\[Rule]1]];altplotset[n_,initial_,group_,groupname_:Null,label_:Null,group2_:Null]:=    Module[{answer,dummy,dummy1,dummy2,element,var,all,tmet,final,power,        increment1,increment2,increment3,minute,hour,rest,fullsettemp,      fullset,        group2,var2},answer=solution[REACTIONS,n,initial];      tmet=tsub[metabolites];      power=Log[10,n];       If[n\[LessEqual]1,        increment1=Abs[-16-Log[10,1/60]]/50;        increment2=Abs[Log[10,1/60]-n]/50;        minute=Table[N[10^dummy],{dummy,-16,Log[10,1/60],increment1}];         hour=Table[N[10^dummy],{dummy,Log[10,1/60],Log[10,n],increment2}];         rest=Null;,        increment1=Abs[-16-Log[10,1/60]]/50;        increment2=Abs[Log[10,1/60]-0]/50;        increment3=Abs[power]/50;		        minute=Table[N[10^dummy],{dummy,-16,Log[10,1/60],increment1}];         hour=Table[N[10^dummy],{dummy,Log[10,1/60],0,increment2}];         rest=Table[N[10^dummy],{dummy,0,power,increment3}];];      fullsettemp=Flatten[Append[minute,hour]];      If[rest\[NotEqual]Null,fullset=Flatten[Append[fullsettemp,rest]];,        fullset=fullsettemp;];	      If[group2===Null,        Table[var[dummy]=            Flatten[Table[                group[[dummy]]/.tmet/.t\[Rule]                      fullset[[dummy1]]/.answer,{dummy1,1,                  Length[fullset]}]],{dummy,1,Length[group]}];        all=list[Length[group]+1];        Do[          all[[dummy1+1]]=            Table[ListPlot[foldlist[var[dummy1],var[dummy2]],                DisplayFunction\[Rule]Identity,Axes\[Rule]False,                PlotJoined\[Rule]True,AspectRatio\[Rule]1],{dummy2,1,                Length[group]}],{dummy1,1,Length[group]}];        If[groupname===Null,          all[[1]]=            Table[If[dummy\[NotEqual]0,                Graphics[Text[group[[dummy]],{0,0},{0,0},{0,-0.75}]],                Graphics[Text["group",{0,0}]]],{dummy,0,Length[group]}];                    Do[all[[dummy]]=              Prepend[all[[dummy]],                Graphics[Text[group[[dummy-1]],{0,0}]]],{dummy,2,              Length[group]+1}];,          all[[1]]=            Table[If[dummy\[NotEqual]0,                Graphics[Text[groupname[[dummy]],{0,0},{0,0},{0,-0.75}]],                Graphics[Text["group",{0,0}]]],{dummy,0,Length[groupname]}];                    Do[all[[dummy]]=              Prepend[all[[dummy]],                Graphics[Text[groupname[[dummy-1]],{0,0}]]],{dummy,2,              Length[groupname]+1}];];,        Table[var[dummy]=            Flatten[Table[                group[[dummy]]/.tmet/.t\[Rule]                      fullset[[dummy1]]/.answer,{dummy1,1,                  Length[fullset]}]],{dummy,1,Length[group]}];        Table[          var2[dummy]=            Flatten[Table[                group2[[dummy]]/.tmet/.t\[Rule]                                        fullset[[dummy1]]/.answer,{dummy1,1,                  Length[fullset]}]],{dummy,1,Length[group2]}];        all=list[Length[group]+1];        Do[          all[[dummy1+1]]=            Table[ListPlot[foldlist[var[dummy1],var2[dummy2]],                DisplayFunction\[Rule]Identity,Axes\[Rule]False,                PlotJoined\[Rule]True,AspectRatio\[Rule]1],{dummy2,1,                Length[group2]}],{dummy1,1,Length[group]}];        If[groupname===Null,          all[[1]]=            Table[If[dummy\[NotEqual]0,                Graphics[Text[group2[[dummy]],{0,0},{0,0},{0,-0.75}]],                Graphics[Text["group",{0,0}]]],{dummy,0,Length[group2]}];                    Do[all[[dummy]]=              Prepend[all[[dummy]],                Graphics[Text[group[[dummy-1]],{0,0}]]],{dummy,2,              Length[group]+1}];,          all[[1]]=            Table[If[dummy\[NotEqual]0,                Graphics[Text[groupname[[dummy]],{0,0},{0,0},{0,-0.75}]],                Graphics[Text["group",{0,0}]]],{dummy,0,Length[groupname]}];                    Do[all[[dummy]]=              Prepend[all[[dummy]],                Graphics[Text[groupname[[dummy-1]],{0,0}]]],{dummy,2,              Length[groupname]+1}];];        If[label=!=Null,all[[1,1]]=Graphics[Text[label,{0,0}]]];        Show[          GraphicsArray[Table[all[[dummy]],{dummy,1,Length[all]}],            ImageSize\[Rule]{450,450},AspectRatio\[Rule]1]]]];plotset[n1_,n_,initial_,group_,groupname_:Null,answer1_:Null,lfont_:9,      nlfont_:8,lsize_:0,psize_:3,points_:50,plrng_:.999]:=    Module[{start,answer,dummy,dummy1,dummy2,element,var,all,tmet,final,      power,        increment1,increment2,increment3,minute,hour,rest,fullsettemp,      fullset,        vertices,set,begin,r,test,fiteq,slope,sval,slopemat,fred,red,gr,bl,        textnum,textslope,upper,size,font,nfont,loop,t0,pone,one,ten,      hundred},      If[answer1===Null,answer=solution[REACTIONS,n,initial],answer=answer1];      tmet=tsub[metabolites];      power=Log[10,n];      If[n1<1/3600,start=1/3600,start=n1];      If[lsize\[Equal]0,size=25*(Length[group]+3),size=lsize];      If[lfont\[Equal]0,font=9,font=lfont];      If[nlfont\[Equal]0,nfont=8,nfont=nlfont];      If[(lsize\[Equal]0)||(lfont\[Equal]0)||(nlfont\[Equal]0),        Print["label font = ",font,"   Number font = ",nfont,          "   Image Size = ",size]];      If[start\[GreaterEqual]n,        Return[Print[                                  "Error! Please check the intial and final time points to make sure \\\\\they are consistent with one another!"]];];      fullset=Table[0,{dummy,1,points+1}];      loop=1;      dummy1=0;      t0=start;      While[loop\[LessEqual]points+1,        dummy1=N[t0*2^(((loop-1)/points)*(Log[2,n]-Log[2,t0]))];        fullset[[loop]]=dummy1;        loop++;];      Table[        var[dummy]=          Flatten[Table[                          group[[dummy]]/.tmet/.t\[Rule]fullset[[dummy1]]/.answer,{dummy1,                1,Length[fullset]}]],{dummy,1,Length[group]}];      If[(start\[LessEqual].1)&&(n\[GreaterEqual].1),        Table[pone[dummy]=            Flatten[Table[                group[[dummy]]/.tmet/.t\[Rule].1/.answer,{dummy1,1,                  1}]],{dummy,1,Length[group]}],        Table[pone[dummy]=            Flatten[Table[                group[[dummy]]/.tmet/.t\[Rule]start/.answer,{dummy1,1,                  1}]],{dummy,1,Length[group]}]];      If[(start\[LessEqual]1)&&(n\[GreaterEqual]1),        Table[one[dummy]=            Flatten[Table[                group[[dummy]]/.tmet/.t\[Rule]1/.answer,{dummy1,1,1}]],{          dummy,            1,Length[group]}],        Table[one[dummy]=            Flatten[Table[                group[[dummy]]/.tmet/.t\[Rule]start/.answer,{dummy1,1,                  1}]],{dummy,1,Length[group]}]];      If[(start\[LessEqual]10)&&(n\[GreaterEqual]10),        Table[ten[dummy]=            Flatten[Table[                group[[dummy]]/.tmet/.t\[Rule]10/.answer,{dummy1,1,                  1}]],{dummy,1,Length[group]}],        Table[ten[dummy]=            Flatten[Table[                group[[dummy]]/.tmet/.t\[Rule]n/.answer,{dummy1,1,1}]],{          dummy,            1,Length[group]}]];      If[(start\[LessEqual]100)&&(n\[GreaterEqual]100),        Table[hundred[dummy]=            Flatten[Table[                group[[dummy]]/.tmet/.t\[Rule]100/.answer,{dummy1,1,                  1}]],{dummy,1,Length[group]}],        Table[hundred[dummy]=            Flatten[Table[                group[[dummy]]/.tmet/.t\[Rule]n/.answer,{dummy1,1,1}]],{          dummy,            1,Length[group]}]];      upper=Table[0,{Length[group]},{Length[group]}];      r=Table[1,{dummy1,Length[group]},{dummy2,Length[group]}];      slopemat=Table[1,{dummy1,Length[group]},{dummy2,Length[group]}];      Do[test=Correlation[var[dummy1],var[dummy2]];        r[[dummy2,dummy1]]=test;        r[[dummy1,dummy2]]=test;        If[Abs[test]>.85,          fiteq=Fit[foldlist[var[dummy1],var[dummy2]],{1,x},x];          slope=(fiteq/.x\[Rule]1)-(fiteq/.x\[Rule]0);          slopemat[[dummy2,dummy1]]=1/slope;          slopemat[[dummy1,dummy2]]=slope;          sval=FromDigits[RealDigits[Abs[slopemat[[dummy1,dummy2]]]+.005]];                    If[slopemat[[dummy1,dummy2]]<0,            textslope=              StringTake[ToString[N[sval,24]],                Max[4,Round[Log[10,Abs[slopemat[[dummy1,dummy2]]]]]]],            textslope=              StringTake[ToString[N[sval,24]],                Max[4,Round[Log[10,Abs[slopemat[[dummy1,dummy2]]]]]]]];];        sval=FromDigits[RealDigits[Abs[r[[dummy1,dummy2]]]+.005]];        If[r[[dummy1,dummy2]]<0,textnum=StringTake[ToString[N[sval,24]],4];           fred=1,textnum=StringTake[ToString[N[sval,24]],4]; fred=0];        red=1; gr=1; bl=1;        Which[r[[dummy1,dummy2]]\[GreaterEqual].9,red=.8; gr=.8; bl=.8,          r[[dummy1,dummy2]]\[LessEqual]-.9,red=.8; gr=.7;           bl=.7,(r[[dummy1,dummy2]]>-.25)&&(r[[dummy1,dummy2]]<.25),red=1;           gr=.8; bl=.8];        If[Abs[r[[dummy1,dummy2]]]>.85,          upper[[dummy1,dummy2]]=            Graphics[{{RGBColor[red,gr,bl],                  Rectangle[{0,0},{1,1}]},{RGBColor[fred,0,0],                  Text[textnum<>"\n"<>textslope,{.5,.5},                    TextStyle\[Rule]{FontFamily\[Rule]"Arial",                        FontSize\[Rule]nfont}]}},AspectRatio\[Rule]1,              Frame\[Rule]False],          upper[[dummy1,dummy2]]=            Graphics[{{RGBColor[red,gr,bl],                  Rectangle[{0,0},{1,1}]},{RGBColor[fred,0,0],                  Text[textnum,{.5,.5},                    TextStyle\[Rule]{FontFamily\[Rule]"Arial",                        FontSize\[Rule]nfont}]}},AspectRatio\[Rule]1,              Frame\[Rule]False]],{dummy1,1,Length[group]},{dummy2,1,          Length[group]}];      all=        Table[Which[dummy1\[Equal]1&&dummy2\[Equal]1,            Graphics[{Thickness[.01],RGBColor[1,1,1],Rectangle[{0,0},{1,1}]},              AspectRatio\[Rule]1],dummy1\[Equal]dummy2,            Graphics[{Thickness[.01],RGBColor[0,0,0],Rectangle[{0,0},{1,1}]},              AspectRatio\[Rule]1],dummy1\[Equal]1,            Graphics[              Text[groupname[[dummy2-1]],{0,0},{0,0},{0,-1},                TextStyle\[Rule]{FontFamily\[Rule]"Arial",                    FontSize\[Rule]font}]],dummy2\[Equal]1,            Graphics[              Text[groupname[[dummy1-1]],{0,0},                TextStyle\[Rule]{FontFamily\[Rule]"Arial",                    FontSize\[Rule]font}]],dummy1>dummy2,            MultipleListPlot[set=foldlist[var[dummy1-1],var[dummy2-1]],              foldlist[pone[dummy1-1],pone[dummy2-1]],              foldlist[one[dummy1-1],one[dummy2-1]],              foldlist[ten[dummy1-1],ten[dummy2-1]],              foldlist[hundred[dummy1-1],                hundred[dummy2-1]],{set[[1]]},{set[[Length[set]]]},              PlotRange\[Rule]{{plrng*Min[var[dummy1-1]],                    Max[var[dummy1-1]]/plrng},{plrng*Min[var[dummy2-1]],                    Max[var[dummy2-1]]/plrng}},            DisplayFunction\[Rule]Identity,              Axes\[Rule]False,PlotJoined\[Rule]True,PlotRange\[Rule]All,              AspectRatio\[Rule]1,              SymbolStyle\[Rule]{RGBColor[0,0,0],RGBColor[1,.4,.4],                  RGBColor[1,0,0],RGBColor[0,1,0],RGBColor[1,1,0],                  RGBColor[0,0,0],RGBColor[0,0,1]},              SymbolShape\[Rule]{PlotSymbol[Triangle,0],                  PlotSymbol[Diamond,psize],PlotSymbol[Diamond,psize],                  PlotSymbol[Diamond,psize],PlotSymbol[Diamond,psize],                  PlotSymbol[Diamond,psize],PlotSymbol[Diamond,psize]}],            dummy2>dummy1,upper[[dummy1-1]][[dummy2-1]]],{dummy1,1,            Length[group]+1},{dummy2,1,Length[group]+1}];      Show[GraphicsArray[all],ImageSize\[Rule]{size,size}]];plotset2::usage=    "plotset[time, initial conditions, variable list, variable names, label]\n\\\\\    Produces an array of phase planes, plotting the components of the \variable list versus one another.\nThere are three arguments:\n\ttime:time \interval\n\t    initial conditions\n\tvariable list: the list of variables to be plotted. \\\\\For     example a user may define a list: adenosine = {ATP, ADP, AMP, ADO} so \that the different adenosine metabolites will be plotted against one another.\\\\\\n\t    variable names: a string list of names corresponding to the variable \list. The default value with refer to the variable list. When the variable \list consists solely of metabolites, variable names does not need to be \specified. It needs to be specified if the variable list consists of fluxes.\n\\\\\\tlabel: This is an optional argument that needs to be entered as a string. \\\\\It is a    label for the whole phase plane set and appears in the upper left corner \\\\\of the matrix of plots.\nExample:plotset[100, 0.8ssic, {HK, PK, PFK}, \{'HK','PK','PFK'}]";plotset::usage=    "plotset[time_zero, time ,initial ,group ,groupname ,answer1 ,font ,nfont \\\\\,size ,psize]\n    Produces an array of phase planes, plotting the components of the variable list versus one another.\nThere are three required arguments:\n\t\time_zero: first time point to be plotted\n\ttime:time interval\n\tinitial: \\\\\initial conditions\n\tgroup: the list of variables to be plotted. For example a user may define a list: adenosine = {ATP, ADP, AMP, ADO} so that the different adenosine metabolites will be plotted against one another.\n\t variable names: a string list of names corresponding to the variable list. The default value will refer to the variable list. When the variable list consists solely of metabolites, variable names does not need to be specified. It needs to be specified if the variable list consists of fluxes.\n\\\\\\tOptional arguments include\n\tanswer1 is the solution returned from \'solution'.\n\tfont is the font size\n\tnfont is the number font size\n\tsize is the plot size (in*72)\n\t psize is \\\\\the size of the points defining the ends of the trajectory.\n\Example:plotset[100, 0.8ssic, {HK, PK, PFK}, {'HK','PK','PFK'}]";plotmodeset::usage=    "plotmodeset[time, initial conditions, cutoff]\nProduces an array of \phase planes for the different modes (see decomp).\nThere are three \arguments:\n\ttime:time interval\n\tinitial conditions\n\tcutoff: the the \cutoff value for the modal matrix.\nplotmodeset is a special case of the \plotset module.";(*--------------------------------------------------------------;  ---------------------------------------------------------------;  ---------------------------------------------------------------;  ---------------------------------------------------------------*)findroots::usage=    "findroots[max_it, damp]\nFind the steady state metabolite     concentrations of the system.\n	There is are two optional   arguments:\nmax_it: maximum number of iterations.\ndamp: the damping factor.\n\nExample:findroots[]\nFinds thesteady state of the cell."; (********************************************************)compare::usage=    " compare[def_enzyme, activity, max_iterations]\nReturns a list of the fractional percent change of the metabolites and fluxes for a specified enzyme deficiency.\nThere are three arguments, the first two are required.\ndef_enzyme: the deficient enzyme\nactivity: the percent normal activity of the enzyme\nmax_iterations: maximum number of iterations for   FindRoot.\nAfter being run, any previously applied enzymopathy will have been removed (note any previously applied loads will NOT be removed).\n\nExample: compare[TPI, 0.01]\nMakes a list of the fractional chanes for the metabolits and fluxes         at the steady state for the cell with a TPI deficiency of 1% normal activity. NOTE: remove enzymopathies before running 'compare'.  This is done with 'resetscale'.  If the enzymopathies are not removed an ERROR is returned."; (********************************************************)map::usage=    "map[]\nMake steady state map of the erythrocyte metabolism. There are not any required arguments arguments.\n\nExample: map[]\nMakes a map fo the steady state of the cell."; (********************************************************)phaseplane::usage=    "phaseplane[time, met1, met2,  initial_cond1, initial_cond2]\nMakes a phase plane between two groups of variable (metabolites or fluxes). 	There are five arguments, the fifth of which is optional.\ntime: Time interval of plot in hours.\nmet1: The first pool of metabolites/fluxes (plotted on the absissa).\nmet2: The second pool of metabolites/fluxes (plotted on the ordinate).\ninitial_cond1: The initial               conditions (required).\ninitial_cond2: An optional additional set of initial conditions\n\nExample: metphaseplane[100, G6P + F6P, MGATP + MGADP + MGAMP + MGDPG23, lowatp]\nA phase plane of G6P and F6P  versus the MG complexed metabolites over 100 hours for the initial condition: lowatp (which has been previously defined).A list of any length of metabolites/fluxes can be plotted; if the list is too long, then the axis labels will be generic, however the generated plot will still be accurate."; (********************************************************)plotphaseplane::usage=    "plotphaseplane[time, met1, met2, solution, 'filename']\nMakes a phase plane between two groups of variable (metabolites or fluxes).  This is used when the solution has already been found using the 'solution' RBC package function. 	There are five arguments, the fifth of which is optional.\ntime: Time interval of plot in hours.\nmet1: The first pool of metabolites/fluxes (plotted on the absissa).\nmet2: The second pool of metabolites/fluxes (plotted on the ordinate).\nsolution: The solution returned from the 'solution' RBC package       function (required).\nfilename: Enclose this in double quotes.  The phase plane will be printed to this file(optional - if not included - no file printed).         "; (********************************************************)altphaseplane::usage=    "See phaseplane. Same calculations as phaseplane, except the plot for altphaseplane is NOT plotted on a log10 scale, nor is it in color, as a result it is usually faster than phaseplane."; (********************************************************)loadphaseplane::usage=    "loadphaseplane[time, met1, met2, initial_cond]\nMake a  phase plane in which a load is applied to the cell. There are four arguments.\ntime: Time interval of plot in hours.\nmet1: The first pool of metabolites/fluxes.\nmet2: The second pool of metabolites/fluxes.\ninitial_cond: Initial conditions for the plots.\n\nExample: loadphaseplane[100, G6P + F6P, MGATP + MGADP + MGAMP + MGDPG23, ssic]\nOnce executed, Mathematica will require input from the user as to which metabolite the load should be applied to, the order of the reaction, and the maximum and minimum values of the rate constant. Initial conditions used are the steady state values for a normal (non-deficient) erythrocyte without any loads. A range of phase planes (3) will be plotted, one for the maximum load, one for the minimum load, and one for an intermediate   load. Note: Any load set prior to executing this function will be reset! A list of any length of metabolites/fluxes can be plotted; if the list is too long, then the axis labels will be generic, however the generated plot will still be accurate."; (********************************************************)decomp::usage=    "decomp[ font, cutoff, linearizepoint, normfactor]\nCalculate the modal matrix of the erythrocyte. There are four optional   arguments.\nfont: The size font desired.\n    cutoff: the value below which elements will be assumed to be 0 (default = 0.05)\nlinearizepoint: defines the point to linearize the system around.  The default is the steady state.  A vector with the concentrations ordered the same as the metabolite vector can be used as input to change the point for the linearization.\nnormfactor: whether to normalize each row of the modal matrix or not. The option entries are yes and no, respectively. The default setting is yes.\n\nExample: {tc,mm} = decomp[6, 0.06, ssic];\nCalculates the modal matrix and the associated time scales at the normal steady state of the cell (the semi-colong prevents the data lists from being printed to the screen, but still prints the modal matrix and time constants in table form.  Modal matrix elements less than 6% of the maximum are set to zero.  The results are printed to the screen in 6 point font.  The rows of the matrix are normalized by the largest value in each row. The results are sent to an array: {tc,mm}."; (********************************************************)poolplot::usage=    "poolplot[time, met1, initial_cond]\nMake a pooled plot of metabolites/fluxes over time. There are three arguments.\ntime: Time intervalof plot in hours.\nmet1: The metabolites.\ninitial_cond: The initial conditions.\n\nExample: poolplot[100, ADO+ AMP+ ADP+ ATP, lowatp]\nMakes a plot of the adenosine metabolites over 100 hours for 'lowatp' initial conditions.\nlogpoolplot is an identical module, except it plots on a log10 scale with respect to time. A list of any length of metabolites/fluxes can       be plotted; if the list is too long, then the axis labels will be generic, however the generated plot will still be accurate.";logpoolplot::usage=    "See poolplot. Same function except a semi-log plot is produced."; (********************************************************)plotpoolplot::usage=    "plotpoolplot[time, met1,solution, 'filename']\nMakes a pool plot (metabolites or fluxes).  This is used when the solution has already been found using the 'solution' RBC package function. 	There are four arguments, the fifth of which is       optional.\ntime: Time interval of plot in hours.\nmet1: The pool of metabolites/fluxes.\nsolution: The solution returned from the 'solution' RBC package function (required).\n                            filename: Enclose this in double quotes.  The phase plane will be printed to this file (optional - if not included - no file printed)"; (********************************************************)energycharge::usage=    "energycharge[time, initial_cond]\nPlot the energy charge of the cell over time.\n\nThere are 2 arguments\ntime: Time interval of plot in hours.\ninitial_cond: The initial conditions.\n\nExample: energycharge[100, lowatp]\nMakes a plot of the energy charge of the cell over 100 hours for 'lowatp' initial conditions.";logenergycharge::usage= "See energycharge. Same function except a log10 scale \\\\                                        is used for time."; (********************************************************)diffeq::usage=    "diffeq[time, initial_cond]\nMake a list of plots for metabolites vs time. There are two arguments.\ntime: Time interval of plot in hours.\ninitial_cond: The initial             conditions.\n\nExample: diffeq[100, lowatp]\nA list of plots over 100 hours, for the initial condition: lowatp."; (********************************************************)fluxdiffeq::usage=    "fluxdiffeq[time, initial_cond]\nMake a list of plots for fluxes vs         time. There are two arguments.\ntime: Time interval of plot in hours.\ninitial_cond: The initial conditions (only one is required).\n\nExample: fluxdiffeq[100,  lowatp]\nA list of plots over 100 hours, for the initial condition: lowatp."; (********************************************************)solution::usage=    "This function is called by many of the RBC package functions to solve the differential equations.  The expert user can directly call this function to gain access to all the data.\n\nsolution[REACTIONS,time,ic]\n\nREACTIONS: just type this word as is - this tells the system to integrate the RBC dynamic mass balance equations.\ntime: the time of integration.\nic: initial conditions.\n\nThis function often preceeds 'plotpoolplot' or \n'plotphaseplane'."; (********************************************************)fixmg::usage=    "Takes a list of ORDERED initial conditions and returns the same list with the Mg complexed metabolites balanced so that total Mg is conserved."; (********************************************************)SSIC::usage=    "Return a list of initial conditions equal to the steady state of the \cell.";load::usage="Apply a load to the cell.";deficientcell::usage="Introduce and enzymopathy to the cell.";resetload::usage="Remove any applied loads.";resetscale::usage="Remove any applied enzymopathies.";changemgt::usage="Change the total MG concentration";resetmgt::usage=  "Reset the total MG concentration to the default value (2.7 \mM)"; changepi::usage="Change the Inorganic Phosphate concentration.";resetpi::usage="Reset the inorganic phosphate concentration to the default \value."; changenae::usage="Change the External Sodium concentration.";resetnae::usage="Reset the external sodium concentration to the default \value."; changert::usage="Change the Donnan Ratio.";resetrt::usage="Reset the Donnan Ratio to the default value.";resetall::usage="Remove all loads and enzymopathies and set all constant \parameters to their default values."; REACTIONS::usage="";DECLARE::usage="";G6P::usage="glucose 6 phosphate";	F6P::usage="fructose 6 phosphate";FDP::usage="fructose diphosphate (bisphosphate)";DHAP::usage="dihydroxy acetone phosphate";GAP::usage="glyceraldehyde 3 phosphate";DPG13::usage="1,2 diphosphoglycerate (bis phosphoglycerate)";DPG23::usage="2,3 diphosphoglycerate (bis phosphoglycerate)";PG3::usage="3 phosphoglycerate";PG2::usage="2 phsophoglycerate";	PEP::usage="phosphoenolpyruvate";PYR::usage="pyruvate";	LAC::usage="lactate";NADH::usage="nicotinamide dinucleotide -- reduced";GL6P::usage="6 phosphogluconolactone";GO6P::usage="6 phosphogluconate";NADPH::usage="nicotinamide dinucleotide phosphate -- reduced";GSH::usage="glutathione -- reduced form";RU5P::usage="ribulose 5 phosphate";R5P::usage="ribose 5 phosphate";	X5P::usage="xylulose 5 phosphate";S7P::usage="seduheptulose 7 phosphate";E4P::usage="erythrose 4 phosphate";ADO::usage="adenosine";	AMP::usage="adensoine mono-phosphate";ADP::usage="adenosine di-phosphate";ATP::usage="adenosine tri-phosphate";PRPP::usage=" phosphoribosyl pyrophosphate";IMP::usage="inosine monophosphate";INO::usage="inosine";	HX::usage="hypoxanthine";R1P::usage="ribose 1 phosphate";	ADE::usage="adenine";NAI::usage="internal sodium concentration ";KI::usage="internal potassium concentration";MGATP::usage="magnesium complexed with ATP";MGADP::usage="magnesium complexed with ADP";MGAMP::usage="magnesium complexed with AMP";MGDPG23::usage="magnesium complexed with 2,3 DPG";MG::usage="uncomplexed magnesium";HK::usage="hexokinase";		PGI::usage="phosphoglucoisomerase";PFK::usage="phosphofructokinase";		ALD::usage="aldolase";TPI::usage="triose phosphate isomerase";GAPDH::usage="glyceraldehyde phosphate dehydrogenase";PGK::usage="phosphoglycerate kinase";DPGM::usage="diphosphoglycerate mutase";DPGase::usage="diphosphoglycerate phosphatase";PGM::usage="phosphoglycerate mutase";EN::usage="enolase";		PK::usage="pyruvate kinase";PEX::usage="pyruvate transport channel";LDH::usage="lactate dehydrogenase";LEX::usage="lactate transport channel";AMPase::usage="adenosine mono-phosphate phosphatase";ADA::usage="adenosine deaminase";		AK::usage="adenosine kinase";ADK::usage="adenylate kinase";AMPDA::usage="adenosine mono-phosphate deaminase";ATPase::usage="adenosine tri-phosphate phosphatase";ADPRT::usage="adenosine phosphoribosyl transferase";G6PDH::usage="glucose 6 phosphate dehydrogenase";PGLase::usage="6 phosphogluconolactonase";GL6PDH::usage="phosphogluconate dehydrogenase";GSSGR::usage="glutathione reducatase";GSHR::usage="glutathione oxidase";RU5PI::usage="ribulose 5 phosphate isomerase";XU5PE::usage="xylulose 5 phosphate epimerase";TKI::usage="transketolase";	TKII::usage="transketolase";TALD::usage="transaldolase";IMPase::usage="inosine mono-phosphate phosphatase";PNPase::usage="purine nucleotide phosphorylase";PRM::usage="phosphoribomutase";PRPPSYN::usage="phosphoribosyl pyrophosphate synthase";HGPRT::usage="hypoxanthine-guanine phosphoribosyl transferase";HXEX::usage="hypoxanthine transport channel";ADEEX::usage="adenine transport channel";ADOEX::usage="adenosine transport channel";NALEAK::usage="sodium leak channel";KLEAK::usage="potassium leak channel";PUMP::usage="sodium/potassium ATPase pump";	(* basic initialization stuff *)var = StringToStream[$Version];If[ Find[var, "Linux"] === "EndOfFile",   palettes :=     Module[ {path1, path2, path3, path4}, 							path1 = RBCSimPath<>"\THINGS_TO_DO.NB";				path2 = RBCSimPath<>"\CHANGE_PARAMETERS.NB";				path3 = RBCSimPath<>"\METABOLITES.NB";				path4 = RBCSimPath<>"\ENZYMES.NB";				Print["Opening palettes"]; NotebookOpen[path1];				 NotebookOpen[path2];				 NotebookOpen[path3];				 NotebookOpen[path4]; ];, 	palettes :=     Module[ {path1, path2, path3, path4},       path1 = RBCSimPath<>"/things~1.nb";				path2 = RBCSimPath<>"/change~1.nb";				path3 = RBCSimPath<>"/metabo~1.nb";				path4 = RBCSimPath<>"/enzymes.nb";				Print["Opening palettes"];				NotebookOpen[path1];				 NotebookOpen[path2];				 NotebookOpen[path3];				 NotebookOpen[path4];				(* Print["Opening ",path1]; NotebookOpen[path1];				Print["Opening ",path2]; NotebookOpen[path2];				Print["Opening ",path3]; NotebookOpen[path3];				Print["Opening ",path4]; NotebookOpen[path4]; *) ];,				  palettes :=     Module[ {path1, path2, path3, path4}, 							path1 = RBCSimPath<>"\THINGS_TO_DO.NB";				path2 = RBCSimPath<>"\CHANGE_PARAMETERS.NB";				path3 = RBCSimPath<>"\METABOLITES.NB";				path4 = RBCSimPath<>"\ENZYMES.NB";				Print["Opening palettes"]; NotebookOpen[path1];				 NotebookOpen[path2];				 NotebookOpen[path3];				 NotebookOpen[path4]; ]; ];  Close[var]; Clear[var];	ssic = SSIC;Print["RBC simulator ",RBCSimVer,    "\n Authors: Jamshidi, Edwards, Church, and Palsson"];If[$VersionNumber < 4,    Print[    "\n The RBC package is optimized for Mathematica 4.0 \n     You are \running Mathmatica version ",$Version],    Print["\nVersion Check: OK \n    You are running Mathmatica version \",$Version]];Begin["`Private`"];End[]EndPackage[];